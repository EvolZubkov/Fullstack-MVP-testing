Перейти к содержимому
История чата



Вы сказали:
Загруженное изображение
21-12.md
Файл
app.js
JavaScript
index.html
Файл
styles.css
Файл
изучи
+ последнее о чем мы говорили это мы создали отдельно чтобы по тестить 3 файла в них именно вопрос

но мне нужно другой формат DND как на картинки, а не внутрь блока вставлять, левый блок должен просто встать рядом с правым притянутся к нему и остаться слева  а не внутри блок справа

Пока продолжаем на отдельных файлах а не в целом диалоге

ChatGPT сказал:

Думал на протяжении 3m 42s
Понял: тебе нужно matching DnD как на скрине — когда “факт” после дропа становится слева от нужного ответа и “примагничивается”, а не вставляется внутрь правого блока.

Я уже переложил разметку/стили/логику в ваших отдельных файлах так, что:

у каждой строки теперь 2 отдельных блока: слева dock (куда “садится” факт), справа фиксированный answer

можно дропать и прямо на ответ — он всё равно “притянется” в левый dock

факт исчезает из пула и появляется слева у выбранного ответа (двойной клик по факту — вернуть в пул)

Вот актуальные версии файлов:

index.html
<!-- index.html -->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Matching DnD Prototype</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="page">
    <div class="card">
      <div class="header">
        <div class="h1">Соответствие (Drag & Drop)</div>
        <div class="hint">Перетащите “Факт” к нужному “Ответу” — он примагнитится слева.</div>
      </div>

      <div class="grid" id="matchingRoot">
        <div class="col">
          <div class="col-title">Факты</div>
          <div class="pool" id="pool"></div>
        </div>

        <div class="col">
          <div class="col-title">Ответы</div>
          <div class="rows" id="rows"></div>
        </div>
      </div>

      <div class="footer">
        <button class="btn" id="resetBtn">Сбросить</button>
        <div class="state" id="stateView"></div>
      </div>
    </div>
  </div>

  <script src="app.js"></script>
</body>
</html>
styles.css
/* styles.css */
:root{
  --background: 225 7% 7%;
  --foreground: 0 0% 98%;
  --border: 0 0% 22%;
  --card: 225 14% 14%;
  --muted: 225 10% 20%;
  --muted-foreground: 0 0% 65%;
  --primary: 217 91% 42%;
  --shadow: 0px 4px 16px rgba(44, 44, 44, 0.5);
  --font-sans: Inter, system-ui, -apple-system, Segoe UI, sans-serif;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: var(--font-sans);
  background: hsl(var(--background));
  color: hsl(var(--foreground));
}

.page{
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 28px 18px;
}

.card{
  width:min(1100px, 100%);
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 22px;
}

.header{ margin-bottom: 16px; }
.h1{ font-size: 22px; font-weight: 800; margin-bottom: 6px; }
.hint{ font-size: 13px; color: hsl(var(--muted-foreground)); }

.grid{
  display:grid;
  grid-template-columns: 340px 1fr;
  gap: 18px;
  margin-top: 12px;
}

.col-title{
  font-weight: 700;
  font-size: 13px;
  color: hsl(var(--muted-foreground));
  margin: 6px 0 10px;
}

.pool{
  min-height: 420px;
  padding: 12px;
  border-radius: 14px;
  border: 1px solid hsl(var(--border));
  background: hsl(var(--muted) / .35);
  display:flex;
  flex-direction:column;
  gap: 10px;
}

.fact{
  user-select:none;
  padding: 10px 12px;
  border-radius: 12px;
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  color: hsl(var(--foreground));
  box-shadow: var(--shadow);
  cursor: grab;
  font-size: 14px;
  line-height: 1.25;
}
.fact:active{ cursor: grabbing; }
.fact.dragging{ opacity:.7; transform: scale(.99); }

.rows{
  display:flex;
  flex-direction:column;
  gap: 12px;
}

/* Одна строка = слева "док" для факта, справа блок ответа */
.pair-row{
  display:grid;
  grid-template-columns: 280px 1fr;
  gap: 14px;
  align-items: stretch;
}

.answer{
  padding: 14px;
  border-radius: 14px;
  border: 1px solid hsl(var(--border));
  background: hsl(var(--card));
  color: hsl(var(--foreground));
  opacity:.95;
  font-size: 14px;
  line-height: 1.35;
}

/* док слева: сюда "примагничивается" факт */
.dock{
  min-height: 44px;
  border-radius: 12px;
  background: hsl(var(--muted));
  border: 1px dashed hsl(var(--border));
  padding: 8px;
  display:flex;
  align-items:center;
  justify-content:flex-start;
  transition: border-color .12s ease, transform .12s ease, background .12s ease;
}
.dock.is-over{ border-color: hsl(var(--primary)); transform: translateY(-1px); }
.dock.is-filled{ border-style: solid; }

.placeholder{
  font-size: 13px;
  color: hsl(var(--muted-foreground));
}

.footer{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
  margin-top: 16px;
  padding-top: 14px;
  border-top: 1px solid hsl(var(--border));
}

.btn{
  background: hsl(var(--primary));
  border: 0;
  color: white;
  padding: 10px 14px;
  border-radius: 12px;
  font-weight: 700;
  cursor: pointer;
}

.state{
  font-size: 12px;
  color: hsl(var(--muted-foreground));
  text-align:right;
  white-space: pre-wrap;
}
app.js
// app.js
const FACTS = [
  { id: 1, text: "ADSL" },
  { id: 2, text: "WIFI" },
  { id: 3, text: "FTTB" },
];

const ANSWERS = [
  {
    id: 101,
    text:
      "это технология высокоскоростного доступа в Интернет, которая использует существующие медные телефонные линии для одновременной передачи данных и голосовой связи, разделяя их по разным частотным диапазонам",
  },
  {
    id: 102,
    text:
      "это технология беспроводной передачи данных, основанная на стандартах IEEE 802.11, которая использует радиоволны для соединения устройств (смартфонов, ноутбуков, планшетов) друг с другом и с Интернетом без использования проводов",
  },
  {
    id: 103,
    text:
      "это технология интернет-подключения, при которой оптоволоконный кабель прокладывается до многоквартирного дома (или другого здания), а уже внутри дома сигнал распределяется по квартирам или офисам через медные кабели",
  },
];

// state: answerId -> factId
let matches = {}; // { 101: 3, 102: 2, ... }
let draggingFactId = null;

const poolEl = document.getElementById("pool");
const rowsEl = document.getElementById("rows");
const stateViewEl = document.getElementById("stateView");
const resetBtn = document.getElementById("resetBtn");

function render() {
  // pool: show only not-used facts
  const usedFactIds = new Set(Object.values(matches));
  poolEl.innerHTML = "";

  FACTS.forEach(f => {
    if (usedFactIds.has(f.id)) return;

    const el = document.createElement("div");
    el.className = "fact";
    el.draggable = true;
    el.dataset.factId = String(f.id);
    el.textContent = f.text;

    poolEl.appendChild(el);
  });

  // rows
  rowsEl.innerHTML = "";
  ANSWERS.forEach(a => {
    const row = document.createElement("div");
    row.className = "pair-row";

    // слева — док (drop-zone) для факта
    const dock = document.createElement("div");
    dock.className = "dock";
    dock.dataset.answerId = String(a.id);

    // справа — фиксированный блок ответа
    const answer = document.createElement("div");
    answer.className = "answer";
    answer.textContent = a.text;

    const factId = matches[a.id];
    if (factId) {
      dock.classList.add("is-filled");

      const f = FACTS.find(x => x.id === factId);
      const chip = document.createElement("div");
      chip.className = "fact";
      chip.draggable = true;
      chip.dataset.factId = String(factId);
      chip.textContent = f ? f.text : ("#" + factId);

      // dblclick вернуть в пул
      chip.addEventListener("dblclick", () => {
        delete matches[a.id];
        render();
      });

      dock.appendChild(chip);
    } else {
      const ph = document.createElement("span");
      ph.className = "placeholder";
      ph.textContent = "Перетащите факт";
      dock.appendChild(ph);
    }

    row.appendChild(dock);
    row.appendChild(answer);
    rowsEl.appendChild(row);
  });

  stateViewEl.textContent = JSON.stringify(matches, null, 2);
}

function getFactIdFromDragEvent(e) {
  try {
    const raw = e.dataTransfer.getData("text/plain");
    if (raw) return Number(raw);
  } catch {}
  return draggingFactId;
}

// --- DnD events (delegation) ---

function getDockFromEventTarget(target) {
  // 1) если на самом доке/внутри него
  const dock = target.closest?.(".dock");
  if (dock) return dock;

  // 2) если кидаем на текст ответа/строку — примагничиваем к доку этой строки
  const row = target.closest?.(".pair-row");
  if (!row) return null;
  return row.querySelector(".dock");
}

document.addEventListener("dragstart", (e) => {
  const factEl = e.target.closest(".fact");
  if (!factEl) return;

  const factId = Number(factEl.dataset.factId);
  if (!factId) return;

  draggingFactId = factId;
  factEl.classList.add("dragging");

  try {
    e.dataTransfer.setData("text/plain", String(factId));
    e.dataTransfer.effectAllowed = "move";
  } catch {}
});

document.addEventListener("dragend", (e) => {
  const factEl = e.target.closest(".fact");
  if (factEl) factEl.classList.remove("dragging");
  draggingFactId = null;

  document.querySelectorAll(".dock.is-over").forEach(s => s.classList.remove("is-over"));
});

document.addEventListener("dragover", (e) => {
  const dock = getDockFromEventTarget(e.target);
  if (!dock) return;
  e.preventDefault();

  // подсветка только текущего дока
  document.querySelectorAll(".dock.is-over").forEach(s => {
    if (s !== dock) s.classList.remove("is-over");
  });

  dock.classList.add("is-over");
  try { e.dataTransfer.dropEffect = "move"; } catch {}
});

document.addEventListener("dragleave", (e) => {
  const dock = e.target.closest?.(".dock");
  if (!dock) return;
  dock.classList.remove("is-over");
});

document.addEventListener("drop", (e) => {
  const dock = getDockFromEventTarget(e.target);
  if (!dock) return;
  e.preventDefault();

  const answerId = Number(dock.dataset.answerId);
  const factId = getFactIdFromDragEvent(e);
  if (!answerId || !factId) return;

  // если этот факт уже где-то стоит — снимаем его со старого ответа
  Object.keys(matches).forEach(aid => {
    if (matches[aid] === factId) delete matches[aid];
  });

  matches[answerId] = factId;

  dock.classList.remove("is-over");
  render();
});

// reset
resetBtn.addEventListener("click", () => {
  matches = {};
  render();
});

// init
render();
Если хочешь “ещё ближе к картинке” (визуально): можно убрать рамку/фон у контейнера строки и сделать оба блока совсем отдельными карточками (сейчас они уже почти так выглядят). Скажи — докручу под 1-в-1.

Вы сказали:
Загруженное изображение
нет опять немного мимо

давай как будто забудем такую логику о которой я описываю, и ты просто сделаешь то как на картинке?

ChatGPT сказал:

Думал на протяжении 1m 14s
Ок, забываем прошлую логику. Сделаем ровно как на скрине:

есть строки;

в каждой строке слева факт-карточка, справа ответ-карточка;

ты перетаскиваешь факты только по левой колонке (на нужную строку) — при дропе факты меняются местами (swap);

ничего “внутрь” правого блока не вставляется — всегда две отдельные карточки рядом.

Скопируй вот эти версии файлов.

index.html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Сопоставление</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap">
    <div class="title">Сопоставление с обратной связью</div>
    <div class="subtitle">Перетащите факт из левой колонки к соответствующему варианту в правой колонке.</div>

    <div class="board" id="board"></div>

    <button class="btn" id="submitBtn" type="button">Отправить</button>
  </div>

  <script src="app.js"></script>
</body>
</html>
styles.css
:root{
  --bg: #ffffff;
  --text: #0f172a;
  --muted: #64748b;
  --tile: #eef0f3;
  --tile2: #f3f4f6;
  --ring: #3b82f6;
  --shadow: 0 1px 0 rgba(0,0,0,.04);
  --radius: 12px;
  --gap: 20px;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

.wrap{
  max-width: 980px;
  margin: 36px auto;
  padding: 0 18px;
}

.title{
  font-size: 26px;
  font-weight: 800;
  margin-bottom: 10px;
}

.subtitle{
  font-size: 16px;
  color: var(--muted);
  margin-bottom: 22px;
}

.board{
  display:flex;
  flex-direction:column;
  gap: 14px;
  margin-bottom: 22px;
}

/* строка как на картинке: слева факт, справа ответ */
.match-row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--gap);
  align-items: stretch;
}

.tile{
  background: var(--tile);
  border-radius: var(--radius);
  padding: 16px 18px;
  box-shadow: var(--shadow);
  min-height: 56px;

  display:flex;
  align-items:center;
  gap: 12px;
}

.answer{
  background: var(--tile2);
}

.fact{
  cursor: grab;
  user-select:none;
}

.fact:active{ cursor: grabbing; }

.grip{
  width: 18px;
  height: 18px;
  opacity: .55;
  flex: 0 0 auto;
}

/* подсветка цели при наведении дропа */
.drop-over{
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}

/* во время перетаскивания */
.dragging{
  opacity: .75;
}

.btn{
  background: var(--tile2);
  border: 0;
  border-radius: var(--radius);
  padding: 14px 22px;
  font-size: 16px;
  cursor:pointer;
}

.btn:hover{
  filter: brightness(0.98);
}
app.js
const FACTS = [
  { id: 1, text: "Факт 2" },
  { id: 2, text: "Факт 1" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

// rowFacts[rowIndex] = factId (слева в этой строке)
let rowFacts = FACTS.map(f => f.id); // как на скрине: факты уже стоят строками
let dragFromRow = null;

const boardEl = document.getElementById("board");
const submitBtn = document.getElementById("submitBtn");

function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M4 7h16v2H4V7zm0 4h16v2H4v-2zm0 4h16v2H4v-2z"/>
    </svg>
  `;
}

function render() {
  boardEl.innerHTML = "";

  const rowsCount = ANSWERS.length;

  for (let i = 0; i < rowsCount; i++) {
    const row = document.createElement("div");
    row.className = "match-row";
    row.dataset.rowIndex = String(i);

    const factTile = document.createElement("div");
    factTile.className = "tile fact";
    factTile.dataset.dropRow = String(i); // куда можно дропнуть

    const answerTile = document.createElement("div");
    answerTile.className = "tile answer";
    answerTile.dataset.dropRow = String(i); // можно дропать и на ответ

    const factId = rowFacts[i];
    const factObj = FACTS.find(f => f.id === factId);

    // факт (draggable)
    factTile.innerHTML = `${gripSvg()}<span>${factObj ? factObj.text : ""}</span>`;
    factTile.draggable = true;
    factTile.dataset.factRow = String(i);

    // ответ
    answerTile.textContent = ANSWERS[i].text;

    row.appendChild(factTile);
    row.appendChild(answerTile);
    boardEl.appendChild(row);
  }
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getDropRow(target) {
  const el = target.closest?.("[data-drop-row]");
  if (!el) return null;
  return Number(el.dataset.dropRow);
}

document.addEventListener("dragstart", (e) => {
  const factEl = e.target.closest?.(".fact");
  if (!factEl) return;

  dragFromRow = Number(factEl.dataset.factRow);
  factEl.classList.add("dragging");

  try {
    e.dataTransfer.setData("text/plain", String(dragFromRow));
    e.dataTransfer.effectAllowed = "move";
  } catch {}
});

document.addEventListener("dragend", (e) => {
  const factEl = e.target.closest?.(".fact");
  if (factEl) factEl.classList.remove("dragging");
  dragFromRow = null;
  clearOver();
});

document.addEventListener("dragover", (e) => {
  const dropRow = getDropRow(e.target);
  if (dropRow === null) return;
  e.preventDefault();

  clearOver();
  const overEl = e.target.closest?.("[data-drop-row]");
  if (overEl) overEl.classList.add("drop-over");
});

document.addEventListener("drop", (e) => {
  const dropRow = getDropRow(e.target);
  if (dropRow === null) return;
  e.preventDefault();

  let fromRow = dragFromRow;

  // fallback если dataTransfer используется
  try {
    const raw = e.dataTransfer.getData("text/plain");
    if (raw !== "") fromRow = Number(raw);
  } catch {}

  if (fromRow === null || Number.isNaN(fromRow)) return;
  if (fromRow === dropRow) return;

  // SWAP фактов между строками (как в классическом matching UI)
  const tmp = rowFacts[dropRow];
  rowFacts[dropRow] = rowFacts[fromRow];
  rowFacts[fromRow] = tmp;

  clearOver();
  render();
});

submitBtn.addEventListener("click", () => {
  // пока просто лог в консоль
  const result = ANSWERS.map((a, i) => ({
    answerId: a.id,
    factId: rowFacts[i],
  }));
  console.log("submit:", result);
});

render();
Если это уже “как на скрине”, дальше скажи только одно: у тебя в реальном кейсе фактов столько же, сколько ответов?
Если не равно, я сразу добавлю “пул” фактов сверху/слева как в некоторых версиях matching, но всё равно без вставки внутрь правой карточки (только рядом).

Вы сказали:
Загруженное изображение
Вот так должны соединятся карточки  
ChatGPT сказал:

Думал на протяжении 1m 38s
Ок, понял по скрину: при совпадении две карточки должны “склеиваться” в одну общую плашку на всю ширину (слева факт + справа ответ внутри одной большой карточки). Ни “внутрь правого блока”, ни две отдельные карточки рядом — именно единый контейнер.

Ниже — рабочая реализация под это поведение (3 файла).
Логика такая:

слева есть “слоты” фактов (по строкам);

справа ответы (по строкам);

перетаскиваешь факт на ответ → строка становится “склеенной” и занимает 2 колонки;

из “склеенной” строки факт можно перетащить на другой ответ или вернуть обратно в левую колонку (на пустой слот).

index.html (оставь такой)
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Сопоставление</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap">
    <div class="title">Сопоставление с обратной связью</div>
    <div class="subtitle">Перетащите факт из левой колонки к соответствующему варианту в правой колонке.</div>

    <div class="grid" id="grid"></div>

    <button class="btn" id="submitBtn" type="button">Отправить</button>
  </div>

  <script src="app.js"></script>
</body>
</html>
styles.css (важное: .joined-row { grid-column: 1 / 3; })
:root{
  --bg: #ffffff;
  --text: #0f172a;
  --muted: #64748b;

  --tile: #e9ebef;
  --tile2: #eceef2;

  --ring: #3b82f6;
  --radius: 12px;
  --gap: 20px;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

.wrap{
  max-width: 980px;
  margin: 36px auto;
  padding: 0 18px;
}

.title{
  font-size: 26px;
  font-weight: 800;
  margin-bottom: 10px;
}

.subtitle{
  font-size: 16px;
  color: var(--muted);
  margin-bottom: 22px;
}

.grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px var(--gap);
  margin-bottom: 22px;
  align-items: stretch;
}

.tile{
  background: var(--tile);
  border-radius: var(--radius);
  padding: 16px 18px;
  min-height: 56px;
  display:flex;
  align-items:center;
  gap: 12px;
}

.answer{
  background: var(--tile2);
}

.fact{
  cursor: grab;
  user-select:none;
}
.fact:active{ cursor: grabbing; }

.grip{
  width: 18px;
  height: 18px;
  opacity: .55;
  flex: 0 0 auto;
}

/* пустой слот слева */
.empty-slot{
  background: transparent;
  border: 2px dashed #d6dae1;
  border-radius: var(--radius);
  min-height: 56px;
}

/* подсветка цели */
.drop-over{
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}

.dragging{ opacity: .75; }

/* ====== СКЛЕЕННАЯ СТРОКА (как на скрине) ====== */
.joined-row{
  grid-column: 1 / 3;      /* <- занимает 2 колонки */
  background: var(--tile);
  border-radius: var(--radius);
  min-height: 56px;

  display:grid;
  grid-template-columns: 1fr 1fr; /* факт | ответ */
  gap: var(--gap);
  align-items: stretch;
  padding: 0; /* внутренняя паддинг у сегментов */
}

.joined-seg{
  display:flex;
  align-items:center;
  gap: 12px;
  padding: 16px 18px;
  background: transparent; /* внешний фон общий */
  border-radius: 0;
}

.joined-seg.answer{
  background: transparent;
}

/* кнопка */
.btn{
  background: var(--tile2);
  border: 0;
  border-radius: var(--radius);
  padding: 14px 22px;
  font-size: 16px;
  cursor:pointer;
}
.btn:hover{ filter: brightness(0.98); }
app.js (склейка + возможность таскать обратно/между ответами)
const FACTS = [
  { id: 1, text: "Факт 2" },
  { id: 2, text: "Факт 1" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

const gridEl = document.getElementById("grid");
const submitBtn = document.getElementById("submitBtn");

// leftSlots[i] = factId | null (что лежит в левой колонке на строке i)
let leftSlots = Array.from({ length: ANSWERS.length }, (_, i) => FACTS[i]?.id ?? null);

// matches[answerId] = factId | null
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

let dragPayload = null; // { from: "left"|"match", index?, answerId?, factId }

function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M4 7h16v2H4V7zm0 4h16v2H4v-2zm0 4h16v2H4v-2z"/>
    </svg>
  `;
}

function factEl(factId, payload) {
  const f = FACTS.find(x => x.id === factId);
  const el = document.createElement("div");
  el.className = "tile fact";
  el.draggable = true;
  el.dataset.factId = String(factId);
  el.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  el.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    el.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  el.addEventListener("dragend", () => {
    el.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return el;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function firstEmptyLeftSlot() {
  return leftSlots.findIndex(x => x === null);
}

function moveFactToLeftSlot(factId, preferredIndex = -1) {
  if (preferredIndex >= 0 && leftSlots[preferredIndex] === null) {
    leftSlots[preferredIndex] = factId;
    return true;
  }
  const idx = firstEmptyLeftSlot();
  if (idx >= 0) {
    leftSlots[idx] = factId;
    return true;
  }
  // если нет пустых — можно просто закинуть в первый (или игнорировать)
  // сделаем безопасно: закинем в конец, если длина позволяет
  return false;
}

function removeFromOrigins(payload) {
  if (!payload) return;

  if (payload.from === "left") {
    if (leftSlots[payload.index] === payload.factId) leftSlots[payload.index] = null;
  } else if (payload.from === "match") {
    if (matches[payload.answerId] === payload.factId) matches[payload.answerId] = null;
  }
}

function render() {
  gridEl.innerHTML = "";

  for (let i = 0; i < ANSWERS.length; i++) {
    const a = ANSWERS[i];
    const matchedFactId = matches[a.id];

    // ===== СКЛЕЕННАЯ СТРОКА =====
    if (matchedFactId) {
      const joined = document.createElement("div");
      joined.className = "joined-row";
      joined.dataset.dropAnswerId = String(a.id); // можно дропать на эту строку тоже

      // левая часть (факт)
      const leftSeg = document.createElement("div");
      leftSeg.className = "joined-seg";
      leftSeg.appendChild(
        factEl(matchedFactId, { from: "match", answerId: a.id, factId: matchedFactId })
      );

      // правая часть (ответ)
      const rightSeg = document.createElement("div");
      rightSeg.className = "joined-seg answer";
      rightSeg.textContent = a.text;

      joined.appendChild(leftSeg);
      joined.appendChild(rightSeg);

      // dragover/drop на joined (замена факта)
      joined.addEventListener("dragover", (e) => {
        e.preventDefault();
        clearOver();
        joined.classList.add("drop-over");
      });
      joined.addEventListener("dragleave", () => joined.classList.remove("drop-over"));
      joined.addEventListener("drop", (e) => {
        e.preventDefault();
        joined.classList.remove("drop-over");

        const payload = getPayload(e) ?? dragPayload;
        if (!payload) return;

        // если кидаем тот же факт — ничего
        if (payload.factId === matches[a.id]) return;

        // старый факт вернуть в левую колонку
        const old = matches[a.id];
        if (old) {
          // если новый приходит из left-слота — вернем старый в тот же слот (если пустой)
          const preferred = payload.from === "left" ? payload.index : -1;
          matches[a.id] = null;
          moveFactToLeftSlot(old, preferred);
        }

        // убрать новый из места происхождения
        removeFromOrigins(payload);

        // поставить новый
        matches[a.id] = payload.factId;

        render();
      });

      gridEl.appendChild(joined);
      continue;
    }

    // ===== НЕСКЛЕЕННАЯ СТРОКА: слева слот (факт или пусто), справа ответ =====

    // LEFT cell
    const leftFactId = leftSlots[i];
    let leftCell;

    if (leftFactId) {
      leftCell = factEl(leftFactId, { from: "left", index: i, factId: leftFactId });
      // можно дропнуть сюда факт из joined (вернуть обратно)
      leftCell.dataset.dropLeftIndex = String(i);
      leftCell.addEventListener("dragover", (e) => {
        e.preventDefault();
        clearOver();
        leftCell.classList.add("drop-over");
      });
      leftCell.addEventListener("dragleave", () => leftCell.classList.remove("drop-over"));
      leftCell.addEventListener("drop", (e) => {
        e.preventDefault();
        leftCell.classList.remove("drop-over");

        const payload = getPayload(e) ?? dragPayload;
        if (!payload) return;

        // если дропнули на занятое — сделаем swap в leftSlots
        const srcFactId = payload.factId;
        const dstFactId = leftSlots[i];

        // убрать источник
        removeFromOrigins(payload);

        // если источник был match — он уже снят, если left — слот уже очищен

        // положить src в этот слот
        leftSlots[i] = srcFactId;

        // то, что было тут, вернуть обратно: либо в старый слот, либо в первый пустой
        if (dstFactId) {
          if (payload.from === "left") {
            // вернуть в исходный слот
            leftSlots[payload.index] = dstFactId;
          } else {
            moveFactToLeftSlot(dstFactId);
          }
        }

        render();
      });
    } else {
      leftCell = document.createElement("div");
      leftCell.className = "empty-slot";
      leftCell.dataset.dropLeftIndex = String(i);

      leftCell.addEventListener("dragover", (e) => {
        e.preventDefault();
        clearOver();
        leftCell.classList.add("drop-over");
      });
      leftCell.addEventListener("dragleave", () => leftCell.classList.remove("drop-over"));
      leftCell.addEventListener("drop", (e) => {
        e.preventDefault();
        leftCell.classList.remove("drop-over");

        const payload = getPayload(e) ?? dragPayload;
        if (!payload) return;

        removeFromOrigins(payload);
        leftSlots[i] = payload.factId;

        render();
      });
    }

    // RIGHT cell (answer drop target)
    const answerCell = document.createElement("div");
    answerCell.className = "tile answer";
    answerCell.textContent = a.text;
    answerCell.dataset.dropAnswerId = String(a.id);

    answerCell.addEventListener("dragover", (e) => {
      e.preventDefault();
      clearOver();
      answerCell.classList.add("drop-over");
    });
    answerCell.addEventListener("dragleave", () => answerCell.classList.remove("drop-over"));
    answerCell.addEventListener("drop", (e) => {
      e.preventDefault();
      answerCell.classList.remove("drop-over");

      const payload = getPayload(e) ?? dragPayload;
      if (!payload) return;

      // убрать новый факт из места происхождения
      removeFromOrigins(payload);

      // присвоить ответу => строка станет "склеенной" (render сделает joined-row)
      matches[a.id] = payload.factId;

      render();
    });

    gridEl.appendChild(leftCell);
    gridEl.appendChild(answerCell);
  }
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map((a) => ({
    answerId: a.id,
    factId: matches[a.id] ?? null,
  }));
  console.log("submit:", result);
});

render();
Если хочешь, могу сразу сделать ещё 2 улучшения “как в тестах”:

чтобы дроп на ответ работал даже если попадёшь не в карточку, а в “пустоту строки”;

чтобы при замене факта на уже склеенной строке старый факт автоматически возвращался на своё прежнее место (а не в первый пустой слот).

Вы сказали:
Загруженное изображение
неплохо но есть баг
1. когда я соединяю одну и карточек, то вторая пропадает ее перекрывает строка, а должно быть, чтобы вторая карточка занимала пустое место той которую выбрали
2. строка сильно увеличивается
ChatGPT сказал:

Думал на протяжении 1m 9s
Да, вижу оба пункта. Причина такая:

сейчас “склейка” делается через CSS grid-span (grid-column: 1 / 3) и у тебя получается нестабильная автосетка, из-за чего следующий ряд может визуально “заезжать”/перекрываться;

плюс в “склеенной” строке я вложил внутрь целую .tile, поэтому высота удваивается (tile внутри tile) → “строка сильно увеличивается”.

Сейчас сделаем правильно как в интерфейсах тестов:

✅ каждая строка — отдельный row-контейнер (2 колонки)
✅ при склейке контейнер получает общий фон и превращается в “единый блок”
✅ внутри — лёгкая draggable-плашка факта (не tile внутри tile), поэтому высота нормальная
✅ ничего не перекрывает, остальные строки всегда занимают своё место

Замени styles.css на это
:root{
  --bg: #ffffff;
  --text: #0f172a;
  --muted: #64748b;

  --tile: #e9ebef;
  --tile2: #eceef2;

  --ring: #3b82f6;
  --radius: 12px;
  --gap: 20px;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

.wrap{
  max-width: 980px;
  margin: 36px auto;
  padding: 0 18px;
}

.title{
  font-size: 26px;
  font-weight: 800;
  margin-bottom: 10px;
}

.subtitle{
  font-size: 16px;
  color: var(--muted);
  margin-bottom: 22px;
}

/* Вместо общего grid — список строк */
.grid{
  display:flex;
  flex-direction:column;
  gap: 14px;
  margin-bottom: 22px;
}

/* одна строка = 2 колонки */
.row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--gap);
  align-items: stretch;
}

/* обычные карточки */
.tile{
  background: var(--tile);
  border-radius: var(--radius);
  padding: 14px 18px;
  min-height: 56px;
  display:flex;
  align-items:center;
  gap: 12px;
}

.answer{ background: var(--tile2); }

.empty-slot{
  background: transparent;
  border: 2px dashed #d6dae1;
  border-radius: var(--radius);
  min-height: 56px;
}

/* лёгкая плашка факта внутри склеенной строки (не tile!) */
.fact-inline{
  display:flex;
  align-items:center;
  gap: 12px;
  cursor: grab;
  user-select:none;
}
.fact-inline:active{ cursor: grabbing; }

.grip{
  width: 18px;
  height: 18px;
  opacity: .55;
  flex: 0 0 auto;
}

.drop-over{
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}

.dragging{ opacity: .75; }

/* ===== СКЛЕЕННАЯ СТРОКА (единая карточка на всю ширину) ===== */
.row.joined{
  background: var(--tile);
  border-radius: var(--radius);
  padding: 0;
  gap: var(--gap);
}

.row.joined .seg{
  padding: 14px 18px;
  display:flex;
  align-items:center;
  gap: 12px;
  min-height: 56px;
}

.row.joined .seg.answer{
  background: transparent;
}

/* кнопка */
.btn{
  background: var(--tile2);
  border: 0;
  border-radius: var(--radius);
  padding: 14px 22px;
  font-size: 16px;
  cursor:pointer;
}
.btn:hover{ filter: brightness(0.98); }
Замени app.js на это
const FACTS = [
  { id: 1, text: "Факт 1" },
  { id: 2, text: "Факт 2" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

const gridEl = document.getElementById("grid");
const submitBtn = document.getElementById("submitBtn");

/**
 * leftSlots[i] = factId | null
 * matches[answerId] = factId | null
 */
let leftSlots = Array.from({ length: ANSWERS.length }, (_, i) => FACTS[i]?.id ?? null);
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

let dragPayload = null; // { from:"left"|"match", index?, answerId?, factId }

function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="currentColor" d="M4 7h16v2H4V7zm0 4h16v2H4v-2zm0 4h16v2H4v-2z"/>
    </svg>
  `;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function removeFromOrigin(payload) {
  if (!payload) return;
  if (payload.from === "left") {
    if (leftSlots[payload.index] === payload.factId) leftSlots[payload.index] = null;
  } else if (payload.from === "match") {
    if (matches[payload.answerId] === payload.factId) matches[payload.answerId] = null;
  }
}

function placeBackToLeft(factId, preferredIndex = -1) {
  if (preferredIndex >= 0 && leftSlots[preferredIndex] === null) {
    leftSlots[preferredIndex] = factId;
    return;
  }
  const idx = leftSlots.findIndex(x => x === null);
  if (idx >= 0) leftSlots[idx] = factId;
}

function makeInlineFact(factId, payload) {
  const f = FACTS.find(x => x.id === factId);

  const el = document.createElement("div");
  el.className = "fact-inline";
  el.draggable = true;
  el.dataset.factId = String(factId);
  el.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  el.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    el.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  el.addEventListener("dragend", () => {
    el.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return el;
}

function makeLeftTile(i) {
  const factId = leftSlots[i];

  if (factId) {
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.dropLeftIndex = String(i);

    const payload = { from: "left", index: i, factId };
    tile.appendChild(makeInlineFact(factId, payload));

    // drop на занятый слот = swap
    tile.addEventListener("dragover", (e) => {
      e.preventDefault();
      clearOver();
      tile.classList.add("drop-over");
    });
    tile.addEventListener("dragleave", () => tile.classList.remove("drop-over"));
    tile.addEventListener("drop", (e) => {
      e.preventDefault();
      tile.classList.remove("drop-over");

      const p = getPayload(e) ?? dragPayload;
      if (!p) return;

      const src = p.factId;
      const dst = leftSlots[i];

      if (src === dst) return;

      removeFromOrigin(p);
      leftSlots[i] = src;

      // вернуть то, что было тут
      if (dst) {
        if (p.from === "left") {
          leftSlots[p.index] = dst;
        } else {
          placeBackToLeft(dst);
        }
      }

      render();
    });

    return tile;
  }

  const empty = document.createElement("div");
  empty.className = "empty-slot";
  empty.dataset.dropLeftIndex = String(i);

  empty.addEventListener("dragover", (e) => {
    e.preventDefault();
    clearOver();
    empty.classList.add("drop-over");
  });
  empty.addEventListener("dragleave", () => empty.classList.remove("drop-over"));
  empty.addEventListener("drop", (e) => {
    e.preventDefault();
    empty.classList.remove("drop-over");

    const p = getPayload(e) ?? dragPayload;
    if (!p) return;

    removeFromOrigin(p);
    leftSlots[i] = p.factId;

    render();
  });

  return empty;
}

function makeAnswerTile(answerId, text) {
  const tile = document.createElement("div");
  tile.className = "tile answer";
  tile.textContent = text;
  tile.dataset.dropAnswerId = String(answerId);

  tile.addEventListener("dragover", (e) => {
    e.preventDefault();
    clearOver();
    tile.classList.add("drop-over");
  });
  tile.addEventListener("dragleave", () => tile.classList.remove("drop-over"));
  tile.addEventListener("drop", (e) => {
    e.preventDefault();
    tile.classList.remove("drop-over");

    const p = getPayload(e) ?? dragPayload;
    if (!p) return;

    // если на этот ответ уже был факт — старый вернем в левую колонку
    const old = matches[answerId];
    if (old) {
      matches[answerId] = null;
      placeBackToLeft(old, p.from === "left" ? p.index : -1);
    }

    removeFromOrigin(p);
    matches[answerId] = p.factId;

    render();
  });

  return tile;
}

function render() {
  gridEl.innerHTML = "";

  for (let i = 0; i < ANSWERS.length; i++) {
    const a = ANSWERS[i];
    const matchedFactId = matches[a.id];

    const row = document.createElement("div");
    row.className = "row";

    if (matchedFactId) {
      // СКЛЕЕННАЯ строка (без grid-span, поэтому ничего не перекрывает)
      row.classList.add("joined");

      const leftSeg = document.createElement("div");
      leftSeg.className = "seg";
      leftSeg.appendChild(makeInlineFact(matchedFactId, { from: "match", answerId: a.id, factId: matchedFactId }));

      const rightSeg = document.createElement("div");
      rightSeg.className = "seg answer";
      rightSeg.textContent = a.text;

      // drop на склеенную строку = замена факта
      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        clearOver();
        row.classList.add("drop-over");
      });
      row.addEventListener("dragleave", () => row.classList.remove("drop-over"));
      row.addEventListener("drop", (e) => {
        e.preventDefault();
        row.classList.remove("drop-over");

        const p = getPayload(e) ?? dragPayload;
        if (!p) return;
        if (p.factId === matches[a.id]) return;

        const old = matches[a.id];
        if (old) {
          matches[a.id] = null;
          placeBackToLeft(old, p.from === "left" ? p.index : -1);
        }

        removeFromOrigin(p);
        matches[a.id] = p.factId;

        render();
      });

      row.appendChild(leftSeg);
      row.appendChild(rightSeg);
    } else {
      // обычная строка: слева слот, справа ответ
      row.appendChild(makeLeftTile(i));
      row.appendChild(makeAnswerTile(a.id, a.text));
    }

    gridEl.appendChild(row);
  }
}

submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map(a => ({ answerId: a.id, factId: matches[a.id] ?? null }));
  console.log("submit:", result);
});

render();
Что исправилось
Ничего не пропадает и не перекрывается — потому что больше нет grid-column: 1 / 3, каждая строка отдельным контейнером.

Строка не раздувается — потому что в “склейке” нет вложенной .tile внутри .tile, там лёгкая .fact-inline.

Если хочешь “в точности как на скрине” ещё деталь: сделать у склеенной строки тот же светлый фон, что у обычной карточки ответа (чуть другой оттенок) — скажи, сделаю.

Вы сказали:
посмотри на это

<div class="os-host os-host-foreign os-theme-dark os-host-resize-disabled os-host-scrollbar-horizontal-hidden os-host-flexbox os-host-transition os-host-scrollbar-vertical-hidden" style="border-top: none; border-bottom: none;"><div class="os-resize-observer-host observed"><div class="os-resize-observer" style="left: 0px; right: auto;"></div></div><div class="os-padding"><div class="os-viewport os-viewport-native-scrollbars-invisible os-viewport-native-scrollbars-overlaid" style=""><div class="os-content" style="padding: 0px; height: 100%; width: 100%;"><div class="CourseTestSection_content__80ad1"><div data-scroll-id="fe22b3d0-a76e-4e75-8d48-ecc47e48e353" data-qa-data="&quot;el&quot;:&quot;block&quot;|&quot;name&quot;:&quot;Сопоставление&quot;|&quot;id&quot;:&quot;fe22b3d0-a76e-4e75-8d48-ecc47e48e353&quot;|&quot;index&quot;:0|" class="PreviewBlock_canvas__2fab5" style="max-width: 980px;"><div class="PreviewColumn_column__2026d" style="flex-basis: 0px; display: flex; padding: 16px 24px; max-width: 980px;"><div class="PreviewAbsolute_root__81d88" style="z-index: 0;"><div class="PreviewShell_wrapper__478d0" data-scroll-id="0e948674-dec4-47ca-8705-efcdfafa847c" style="margin: 0px; padding: 0px;"><div class="PreviewShell_shell__a64c7 PreviewShell_shell__a64c7" style="width: 100%; height: 100%;"><div class="RectangleElement_root__15696" style="background-color: rgba(255, 255, 255, 0); border-radius: 0px; border-style: none; border-color: var(--brand-borderColor); border-width: 1px; box-shadow: none;"></div></div><div class="PreviewShell_overlay__d778f PreviewShell_overlayHidden__183e0" aria-hidden="true"></div></div></div><div class="PreviewRow_row__b7c42" style="flex-grow: 0; min-height: 40px;"><div class="PreviewColumn_column__2026d" style="flex-basis: auto; display: flex;"><div class="PreviewRow_row__b7c42" style="flex-grow: 0; min-height: 40px;"><div class="PreviewColumn_column__2026d" style="flex-basis: auto; display: flex;"><div class="PreviewShell_wrapper__478d0" data-scroll-id="ec6ae427-a3c5-4e29-b04e-56bc41bd08a8" style="margin: 24px 0px 40px; padding: 0px;"><div class="PreviewShell_shell__a64c7 PreviewShell_shell__a64c7" style="width: auto; height: auto;"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: var(--brand-primaryTextColor); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><h3 class="Element_heading3__52bcd" element="[object Object]"><span class="">Сопоставление с обратной связью</span></h3></div></div><div class="PreviewShell_overlay__d778f PreviewShell_overlayHidden__183e0" aria-hidden="true"></div></div></div></div><div class="PreviewRow_row__b7c42" style="flex-grow: 0;"><div class="PreviewColumn_column__2026d" style="flex-basis: auto; display: flex;"><div class="PreviewShell_wrapper__478d0" data-scroll-id="7f6922ca-9a24-4397-900b-8d2a07f94a61" style="margin: 0px 0px 32px; padding: 0px;"><div class="PreviewShell_shell__a64c7 PreviewShell_shell__a64c7" style="width: auto; height: auto;"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: var(--brand-errorColor); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><div class="" element="[object Object]"><span class="" style="color: var(--brand-secondaryTextColor);">Перетащите факт из левой колонки к соответствующему варианту в правой колонке.</span></div></div></div><div class="PreviewShell_overlay__d778f PreviewShell_overlayHidden__183e0" aria-hidden="true"></div></div></div></div><div class="PreviewRow_row__b7c42" style="flex-grow: 0; min-height: 0px;"><div class="PreviewColumn_column__2026d" style="flex-basis: 0px; display: none;"><div class="PreviewShell_wrapper__478d0" data-scroll-id="8ea5debe-4f4e-4c5d-bb4d-231353ac7be7" style="margin: 0px; padding: 0px;"><div class="PreviewShell_shell__a64c7 PreviewShell_shell__a64c7" style="width: auto; height: auto;"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: rgba(105, 119, 135, 1); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><div class="" element="[object Object]"><span class="">Нажмите на стрелку справа, чтобы выбрать соответствующий вариант к факту. Чтобы отменить выбор, нажмите на стрелку и измените свой выбор.</span></div></div></div><div class="PreviewShell_overlay__d778f PreviewShell_overlayHidden__183e0" aria-hidden="true"></div></div></div></div><div class="PreviewRow_row__b7c42" style="flex-grow: 0; min-height: 40px;"><div class="PreviewColumn_column__2026d" style="flex-basis: auto; display: flex;"><div class="PreviewShell_wrapper__478d0" data-scroll-id="e74a9454-acdb-430e-bfcb-9c84d0aa9ee1" style="margin: 0px; padding: 0px;"><div class="PreviewShell_shell__a64c7 PreviewShell_shell__a64c7" style="width: auto; height: auto;"><div><div><div class="DefaultElementPreview_matchingElement__67b6c"><div style="margin-bottom: 12px; height: 64px;"><div><div class="AnswerFeedback_root__a720d"><div class="sc-ftmehX jtSFeP"><div class="sc-kEsJEW cCEiGX"><div class="AnswerFeedback_image__1c184" style="background-image: url(&quot;https://prod-app-v2.storage.yandexcloud.net/static/a645085b4e9f063e628886d2b88a8200__Frame-2.svg&quot;); background-color: transparent;"></div></div><div class="AnswerFeedback_content__e5724"><div class="DefaultElementPreview_row__afd10"><div class="DefaultElementPreview_item__bcbad"><div data-rfd-droppable-id="source0" data-rfd-droppable-context-id=":r5m:"><div id="itemWrapper" data-rfd-draggable-context-id=":r5m:" data-rfd-draggable-id="ibKG18Clb8ihgwzGMiyPz" tabindex="0" role="button" aria-describedby="rfd-hidden-text-:r5m:-hidden-text-:r5n:" data-rfd-drag-handle-draggable-id="ibKG18Clb8ihgwzGMiyPz" data-rfd-drag-handle-context-id=":r5m:" draggable="false" class="sc-jQybuE hMpQss" style="background-color: var(--brand-infoColor); padding: 16px 24px; border-bottom-left-radius: var(--brand-borderRadius); border-top-left-radius: var(--brand-borderRadius); border-color: rgba(119, 0, 255, 0); border-width: 1px; font-family: ad29aa21-6fb5-4239-a957-c66a556239f6, sans-serif; font-weight: 400; font-style: normal; font-size: 20px; line-height: 1.2; color: var(--brand-primaryTextColor); height: 64px;"><div class="MatchingItem_item__b03eb" id="itemContent"><div data-qa-data="&quot;el&quot;:&quot;courseMatchingDrag&quot;|&quot;index&quot;:0|" style="margin-right: 12px;"><div class="MatchingItem_burgerIcon__46d81" style="color: var(--brand-primaryTextColor);"><svg width="1em" height="1em" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" data-qa-data="&quot;el&quot;:&quot;icon&quot;|&quot;icon&quot;:&quot;otherBurger&quot;|" class="Icons_root__35416 Icons_mini__8b251"><path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></div><div class="DefaultElementPreview_text__cca25"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: var(--brand-primaryTextColor); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><div class="" element="[object Object]"><span class="">Факт 1</span></div></div></div></div></div></div></div><div style="flex: 0 0 24px;"></div><div class="DefaultElementPreview_item__bcbad"><div data-rfd-droppable-id="ibKG18Clb8ihgwzGMiyPz" data-rfd-droppable-context-id=":r5m:"><div id="itemWrapper" class="sc-jQybuE kqMqBW" style="background-color: var(--brand-infoColor); padding: 16px 24px; border-bottom-right-radius: var(--brand-borderRadius); border-top-right-radius: var(--brand-borderRadius); border-color: rgba(119, 0, 255, 0); border-width: 1px; font-family: ad29aa21-6fb5-4239-a957-c66a556239f6, sans-serif; font-weight: 400; font-style: normal; font-size: 20px; line-height: 1.2; color: var(--brand-primaryTextColor); height: 64px;"><div class="MatchingItem_item__b03eb" id="itemContent"><div class="DefaultElementPreview_text__cca25"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: var(--brand-primaryTextColor); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><div class="" element="[object Object]"><span class="">Ответ 1</span></div></div></div></div></div></div></div></div></div></div></div></div></div><div style="height: 64px;"><div><div class="AnswerFeedback_root__a720d"><div class="sc-ftmehX jtSFeP"><div class="sc-kEsJEW cCEiGX"><div class="AnswerFeedback_image__1c184" style="background-image: url(&quot;https://prod-app-v2.storage.yandexcloud.net/static/a645085b4e9f063e628886d2b88a8200__Frame-2.svg&quot;); background-color: transparent;"></div></div><div class="AnswerFeedback_content__e5724"><div class="DefaultElementPreview_row__afd10"><div class="DefaultElementPreview_item__bcbad"><div data-rfd-droppable-id="source1" data-rfd-droppable-context-id=":r5m:"><div id="itemWrapper" data-rfd-draggable-context-id=":r5m:" data-rfd-draggable-id="8dCe6w3dTgbFARUWve2K-" tabindex="0" role="button" aria-describedby="rfd-hidden-text-:r5m:-hidden-text-:r5n:" data-rfd-drag-handle-draggable-id="8dCe6w3dTgbFARUWve2K-" data-rfd-drag-handle-context-id=":r5m:" draggable="false" class="sc-jQybuE bIApUw" style="background-color: var(--brand-infoColor); padding: 16px 24px; border-bottom-left-radius: var(--brand-borderRadius); border-top-left-radius: var(--brand-borderRadius); border-color: rgba(119, 0, 255, 0); border-width: 1px; font-family: ad29aa21-6fb5-4239-a957-c66a556239f6, sans-serif; font-weight: 400; font-style: normal; font-size: 20px; line-height: 1.2; color: var(--brand-primaryTextColor); height: 64px;"><div class="MatchingItem_item__b03eb" id="itemContent"><div data-qa-data="&quot;el&quot;:&quot;courseMatchingDrag&quot;|&quot;index&quot;:1|" style="margin-right: 12px;"><div class="MatchingItem_burgerIcon__46d81" style="color: var(--brand-primaryTextColor);"><svg width="1em" height="1em" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" data-qa-data="&quot;el&quot;:&quot;icon&quot;|&quot;icon&quot;:&quot;otherBurger&quot;|" class="Icons_root__35416 Icons_mini__8b251"><path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></div><div class="DefaultElementPreview_text__cca25"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: var(--brand-primaryTextColor); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><div class="" element="[object Object]"><span class="">Факт 2</span></div></div></div></div></div></div></div><div style="flex: 0 0 24px;"></div><div class="DefaultElementPreview_item__bcbad"><div data-rfd-droppable-id="8dCe6w3dTgbFARUWve2K-" data-rfd-droppable-context-id=":r5m:"><div id="itemWrapper" class="sc-jQybuE kqMqBW" style="background-color: var(--brand-infoColor); padding: 16px 24px; border-bottom-right-radius: var(--brand-borderRadius); border-top-right-radius: var(--brand-borderRadius); border-color: rgba(119, 0, 255, 0); border-width: 1px; font-family: ad29aa21-6fb5-4239-a957-c66a556239f6, sans-serif; font-weight: 400; font-style: normal; font-size: 20px; line-height: 1.2; color: var(--brand-primaryTextColor); height: 64px;"><div class="MatchingItem_item__b03eb" id="itemContent"><div class="DefaultElementPreview_text__cca25"><div class="RichText_root__76872" style="--base-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --base-fontWeight: 400; --base-fontStyle: normal; --base-fontSize: 20px; --base-lineHeight: 1.2; --base-color: var(--brand-primaryTextColor); --caption-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --caption-fontWeight: 400; --caption-fontStyle: normal; --caption-fontSize: 14px; --caption-lineHeight: 1.2; --caption-color: var(--brand-secondaryTextColor); --h1-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h1-fontWeight: 300; --h1-fontStyle: normal; --h1-fontSize: 32px; --h1-lineHeight: 1.2; --h1-color: var(--brand-primaryTextColor); --h2-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h2-fontWeight: 700; --h2-fontStyle: normal; --h2-fontSize: 28px; --h2-lineHeight: 1.2; --h2-color: var(--brand-primaryTextColor); --h3-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h3-fontWeight: 700; --h3-fontStyle: normal; --h3-fontSize: 24px; --h3-lineHeight: 1.2; --h3-color: var(--brand-primaryTextColor); --h4-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --h4-fontWeight: 700; --h4-fontStyle: normal; --h4-fontSize: 20px; --h4-lineHeight: 1.2; --h4-color: var(--brand-primaryTextColor); --list-fontWeight: 400; --list-fontStyle: normal; --list-spacing: 8px; --list-gap: 3px; --list-color: var(--brand-primaryTextColor); --list-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --list-fontSize: 20px; --list-lineHeight: 1.2; --quote-fontWeight: 400; --quote-fontStyle: normal; --quote-lineHeight: 1.2; --quote-color: var(--brand-primaryTextColor); --quote-borderLeftColor: var(--brand-primaryColor); --quote-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --quote-fontSize: 20px; --link-color: #736eef; --link-textDecoration: underline; --link-hoverColor: var(--brand-focusedColor); --link-fontFamily: 'ad29aa21-6fb5-4239-a957-c66a556239f6', sans-serif; --link-fontWeight: 400; --link-fontStyle: normal; --link-fontSize: 20px; --link-lineHeight: 1.2;"><div class="" element="[object Object]"><span class="">Ответ 2</span></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div></div></div></div><div class="PreviewShell_overlay__d778f PreviewShell_overlayHidden__183e0" aria-hidden="true"></div></div></div></div><div class="PreviewRow_row__b7c42" style="flex-grow: 0; min-height: 40px;"><div class="PreviewColumn_column__2026d" style="flex-basis: auto; display: flex;"><div class="PreviewShell_wrapper__478d0" data-scroll-id="77a69349-3fa0-4445-b217-6640067fbb88" style="margin: 24px 0px; padding: 0px; align-items: start;"><div class="PreviewShell_shell__a64c7 PreviewShell_shell__a64c7" style="width: auto; height: auto;"><button data-qa-data="&quot;el&quot;:&quot;courseButton&quot;|&quot;value&quot;:&quot;validate&quot;|&quot;label&quot;:&quot;Отправить&quot;|&quot;disabled&quot;:true|" disabled="" class="sc-iwXfZk QkXgn">Отправить</button></div><div class="PreviewShell_overlay__d778f PreviewShell_overlayHidden__183e0" aria-hidden="true"></div></div></div></div></div></div></div><div class="PreviewBlock_blockActions__3f1e0"><div class="ControlsGroup_root__1b29f"><div><div data-qa-data="&quot;el&quot;:&quot;layoutAction&quot;|&quot;name&quot;:&quot;EDIT&quot;|" class="ControlItem_root__1f628" testdata="&quot;el&quot;:&quot;dropdown&quot;|&quot;name&quot;:&quot;_UNDEFINED_&quot;|&quot;open&quot;:false|"><svg width="1em" height="1em" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" data-qa-data="&quot;el&quot;:&quot;icon&quot;|&quot;icon&quot;:&quot;penEdit&quot;|" class="Icons_root__35416"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.41079 13.0157L13.0158 4.41074C13.3408 4.08574 13.8683 4.08574 14.1933 4.41074L15.59 5.80741C15.915 6.13241 15.915 6.65991 15.59 6.98491L6.98413 15.5891C6.82829 15.7457 6.61663 15.8332 6.39579 15.8332H4.16663V13.6041C4.16663 13.3832 4.25413 13.1716 4.41079 13.0157Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M11.4583 5.9668L14.0333 8.5418" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></div></div></div></div></div><div class="AbsolutePortal_root__0ce01 reset_resetBaseFont__9336b"></div></div></div></div><div class="os-scrollbar os-scrollbar-horizontal os-scrollbar-unusable os-scrollbar-auto-hidden"><div class="os-scrollbar-track os-scrollbar-track-off"><div class="os-scrollbar-handle" style="width: 100%; transform: translate(0px, 0px);"></div></div></div><div class="os-scrollbar os-scrollbar-vertical os-scrollbar-auto-hidden os-scrollbar-unusable"><div class="os-scrollbar-track os-scrollbar-track-off"><div class="os-scrollbar-handle" style="height: 100%; transform: translate(0px, 0px);"></div></div></div><div class="os-scrollbar-corner"></div></div>
ChatGPT сказал:

Думал на протяжении 53s
Вижу. Это прям “как в проде” сделано, и из этого DOM можно вытащить ключевую идею, почему у нас раньше всё ломалось.

Что важно в твоём DOM
Они НЕ делают один элемент на 2 колонки.
Там всегда остаются две отдельные карточки (левая и правая), просто у них:

одинаковый фон (background-color: var(--brand-infoColor))

у левой карточки скруглены только левые углы

у правой карточки скруглены только правые углы

высота жёстко height: 64px

Это даёт эффект “склеено в одну”, но вёрстка не перекрывает соседние строки.

Между карточками у них стоит спейсер flex: 0 0 24px; (фиксированный зазор).
А ощущение “связи” часто добивается ещё и картинкой/декором (AnswerFeedback_image__... Frame-2.svg), которая визуально “соединяет”.

По data-rfd-* видно, что это react-beautiful-dnd / @hello-pangea/dnd:

слева droppable source0/source1

draggable — “Факт”

справа — отдельный droppable под “Ответ”

Как это повторить у нас (без React), чтобы было 1-в-1 по поведению и виду
1) Вообще не делай “joined-row” который span’ится на всю ширину
Оставляй всегда структуру “строка = 2 колонки”.

2) Делай “склейку” только стилями двух половинок
Добавь в styles.css (или замени соответствующие куски):

.row{
  display:flex;
  align-items:stretch;
}

.row-gap{
  flex: 0 0 24px; /* как у них */
}

.tile{
  height: 64px;           /* как у них */
  min-height: 64px;
  padding: 16px 24px;
  display:flex;
  align-items:center;
  border-radius: 12px;
}

/* состояние "склеено" */
.row.is-joined .tile.left{
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.row.is-joined .tile.right{
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

/* один фон на обе половины */
.row.is-joined .tile.left,
.row.is-joined .tile.right{
  background: var(--tile); /* или твой var(--brand-infoColor) */
}
3) В app.js при совпадении НЕ “превращай строку в одну карточку”
Просто ставь row.classList.add("is-joined") и давай плиткам классы left/right.

Схема рендера строки должна быть всегда такой:

<div class="row is-joined">
  <div class="tile left">Факт</div>
  <div class="row-gap"></div>
  <div class="tile right">Ответ</div>
</div>
Почему это решит оба твоих бага
ничего не перекрывается: потому что нет grid-span и нет “элемент занял две строки”

высота не раздувается: потому что это не “tile внутри tile”, а одна строка фиксированной высоты 64px

Если хочешь — я прямо сейчас перепишу твои текущие 3 файла под эту структуру “как в DOM” (row flex + spacer 24 + joined через border-radius).
Скажи только: в “склеенном” состоянии должен быть зазор 24px как у них, или “без зазора, прямо слиплись вплотную”?

Вы сказали:
перепеши все 3 файла целиком
ChatGPT сказал:

Думал на протяжении 1m 25s
Ок — переписал все 3 файла целиком в стиле как в твоём DOM:

всегда две карточки в строке (левая/правая) + спейсер 24px

“склейка” делается только стилями: общий фон + скругления только снаружи

фиксированная высота 64px, поэтому “строка не раздувается”

ничего не перекрывает: нет grid-column: 1 / 3

DnD:

можно перетаскивать факт на ответ (справа)

можно перетаскивать факт обратно в пустой слот слева

можно swap факты между левыми слотами (дроп на занятый слот)

index.html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Сопоставление</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap">
    <h1 class="title">Сопоставление с обратной связью</h1>
    <p class="subtitle">
      Перетащите факт из левой колонки к соответствующему варианту в правой колонке.
    </p>

    <div class="board" id="board"></div>

    <button class="btn" id="submitBtn" type="button" disabled>Отправить</button>
  </div>

  <script src="app.js"></script>
</body>
</html>
styles.css
:root{
  --bg: #ffffff;
  --text: #0f172a;
  --muted: #64748b;

  /* близко к “infoColor” на скрине */
  --card: #e9ebef;
  --dash: #d6dae1;
  --ring: #3b82f6;

  --radius: 12px;
  --gap: 24px; /* как в DOM: flex: 0 0 24px */
  --h: 64px;   /* как в DOM: height: 64px */
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

.wrap{
  max-width: 980px;
  margin: 36px auto;
  padding: 0 18px;
}

.title{
  margin: 0 0 10px 0;
  font-size: 28px;
  font-weight: 800;
}

.subtitle{
  margin: 0 0 22px 0;
  font-size: 16px;
  color: var(--muted);
}

.board{
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-bottom: 22px;
}

/* одна строка = левая карточка + спейсер + правая карточка */
.row{
  display:flex;
  align-items:stretch;
}

.gap{
  flex: 0 0 var(--gap);
}

/* карточки */
.tile{
  height: var(--h);
  min-height: var(--h);
  flex: 1 1 0;
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px 24px;
  display:flex;
  align-items:center;
  gap: 12px;
  overflow:hidden;
}

/* пустой слот слева */
.empty{
  height: var(--h);
  min-height: var(--h);
  flex: 1 1 0;
  border: 1.5px dashed var(--dash);
  border-radius: var(--radius);
  background: transparent;
}

/* “склейка” как в DOM: только внешние углы */
.row.is-joined .tile.left{
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.row.is-joined .tile.right{
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

/* контент факта (draggable) */
.fact{
  display:flex;
  align-items:center;
  gap: 12px;
  user-select:none;
  cursor: grab;
  width: 100%;
}
.fact:active{ cursor: grabbing; }

.grip{
  width: 18px;
  height: 18px;
  opacity: .55;
  flex: 0 0 auto;
}

/* подсветка drop зоны */
.drop-over{
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}

.dragging{
  opacity: .75;
}

/* кнопка */
.btn{
  background: #eef0f3;
  border: 0;
  border-radius: var(--radius);
  padding: 14px 22px;
  font-size: 16px;
  cursor:pointer;
}
.btn:disabled{
  opacity: .55;
  cursor: not-allowed;
}
.btn:not(:disabled):hover{
  filter: brightness(0.98);
}
app.js
// --- data ---
const FACTS = [
  { id: 1, text: "Факт 1" },
  { id: 2, text: "Факт 2" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

// --- state ---
// leftSlots[i] = factId | null (то, что лежит слева на строке i, пока НЕ присвоено ответу)
let leftSlots = Array.from({ length: ANSWERS.length }, (_, i) => FACTS[i]?.id ?? null);

// matches[answerId] = factId | null (то, что присвоили ответу)
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

// “домашний” слот для возврата факта (чтобы замены выглядели аккуратно)
const homeIndexByFactId = new Map();
leftSlots.forEach((fid, idx) => {
  if (fid != null) homeIndexByFactId.set(fid, idx);
});

let dragPayload = null;
// payload = { factId, from: "left"|"match", leftIndex?: number, answerId?: number }

const boardEl = document.getElementById("board");
const submitBtn = document.getElementById("submitBtn");

// --- helpers ---
function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  `;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function removeFromOrigin(p) {
  if (!p) return;

  if (p.from === "left") {
    if (leftSlots[p.leftIndex] === p.factId) leftSlots[p.leftIndex] = null;
  } else if (p.from === "match") {
    if (matches[p.answerId] === p.factId) matches[p.answerId] = null;
  }
}

function firstEmptyLeftIndex() {
  return leftSlots.findIndex(x => x === null);
}

function returnFactToLeft(factId, preferredIndex = -1) {
  // 1) если есть предпочтительный слот (обычно — откуда факт пришёл)
  if (preferredIndex >= 0 && leftSlots[preferredIndex] === null) {
    leftSlots[preferredIndex] = factId;
    return;
  }
  // 2) если есть “домашний” слот
  const home = homeIndexByFactId.get(factId);
  if (home != null && leftSlots[home] === null) {
    leftSlots[home] = factId;
    return;
  }
  // 3) первый пустой
  const idx = firstEmptyLeftIndex();
  if (idx >= 0) leftSlots[idx] = factId;
}

function allMatched() {
  return ANSWERS.every(a => matches[a.id] != null);
}

function updateButton() {
  submitBtn.disabled = !allMatched();
}

// --- render ---
function makeFactNode(factId, payload) {
  const f = FACTS.find(x => x.id === factId);

  const wrap = document.createElement("div");
  wrap.className = "fact";
  wrap.draggable = true;

  wrap.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  wrap.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    wrap.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  wrap.addEventListener("dragend", () => {
    wrap.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return wrap;
}

function render() {
  boardEl.innerHTML = "";

  for (let rowIndex = 0; rowIndex < ANSWERS.length; rowIndex++) {
    const answer = ANSWERS[rowIndex];
    const matchedFactId = matches[answer.id];

    const row = document.createElement("div");
    row.className = "row";
    if (matchedFactId) row.classList.add("is-joined");

    // --- LEFT ---
    let leftNode;

    if (matchedFactId) {
      // если ответ уже “склеен” — слева показываем matched факт
      const leftTile = document.createElement("div");
      leftTile.className = "tile left";
      leftTile.appendChild(
        makeFactNode(matchedFactId, { from: "match", answerId: answer.id, factId: matchedFactId })
      );

      // drop на левую часть склеенной строки: swap/перенос влево (как на обычный слот)
      leftTile.addEventListener("dragover", (e) => {
        e.preventDefault();
        clearOver();
        leftTile.classList.add("drop-over");
      });
      leftTile.addEventListener("dragleave", () => leftTile.classList.remove("drop-over"));
      leftTile.addEventListener("drop", (e) => {
        e.preventDefault();
        leftTile.classList.remove("drop-over");

        const p = getPayload(e) ?? dragPayload;
        if (!p) return;

        // меняем факт в этом ответе
        const old = matches[answer.id];
        if (old && old === p.factId) return;

        if (old) {
          matches[answer.id] = null;
          returnFactToLeft(old, p.from === "left" ? p.leftIndex : -1);
        }

        removeFromOrigin(p);
        matches[answer.id] = p.factId;

        render();
      });

      leftNode = leftTile;
    } else {
      // обычный левый слот
      const factId = leftSlots[rowIndex];

      if (factId != null) {
        const leftTile = document.createElement("div");
        leftTile.className = "tile left";
        leftTile.appendChild(makeFactNode(factId, { from: "left", leftIndex: rowIndex, factId }));

        // drop на занятый слот = swap (и можно вернуть факт из match)
        leftTile.addEventListener("dragover", (e) => {
          e.preventDefault();
          clearOver();
          leftTile.classList.add("drop-over");
        });
        leftTile.addEventListener("dragleave", () => leftTile.classList.remove("drop-over"));
        leftTile.addEventListener("drop", (e) => {
          e.preventDefault();
          leftTile.classList.remove("drop-over");

          const p = getPayload(e) ?? dragPayload;
          if (!p) return;

          const src = p.factId;
          const dst = leftSlots[rowIndex];
          if (src === dst) return;

          removeFromOrigin(p);

          // положили src сюда
          leftSlots[rowIndex] = src;

          // то, что было здесь, вернули обратно
          if (dst != null) {
            if (p.from === "left") {
              leftSlots[p.leftIndex] = dst;
            } else {
              returnFactToLeft(dst);
            }
          }

          render();
        });

        leftNode = leftTile;
      } else {
        const empty = document.createElement("div");
        empty.className = "empty left";
        empty.dataset.leftIndex = String(rowIndex);

        empty.addEventListener("dragover", (e) => {
          e.preventDefault();
          clearOver();
          empty.classList.add("drop-over");
        });
        empty.addEventListener("dragleave", () => empty.classList.remove("drop-over"));
        empty.addEventListener("drop", (e) => {
          e.preventDefault();
          empty.classList.remove("drop-over");

          const p = getPayload(e) ?? dragPayload;
          if (!p) return;

          removeFromOrigin(p);
          leftSlots[rowIndex] = p.factId;

          render();
        });

        leftNode = empty;
      }
    }

    // --- GAP ---
    const gap = document.createElement("div");
    gap.className = "gap";

    // --- RIGHT (answer) ---
    const rightTile = document.createElement("div");
    rightTile.className = "tile right";
    rightTile.textContent = answer.text;

    // drop на ответ: назначаем факт этому ответу
    rightTile.addEventListener("dragover", (e) => {
      e.preventDefault();
      clearOver();
      rightTile.classList.add("drop-over");
    });
    rightTile.addEventListener("dragleave", () => rightTile.classList.remove("drop-over"));
    rightTile.addEventListener("drop", (e) => {
      e.preventDefault();
      rightTile.classList.remove("drop-over");

      const p = getPayload(e) ?? dragPayload;
      if (!p) return;

      // если тут уже был факт — вернём его в левую колонку
      const old = matches[answer.id];
      if (old != null && old !== p.factId) {
        matches[answer.id] = null;
        returnFactToLeft(old, p.from === "left" ? p.leftIndex : -1);
      }

      // если в этой строке слева лежал какой-то факт (а мы сейчас делаем match),
      // его нельзя “потерять”. Вернём его в левую колонку.
      // (актуально, когда пихаем в ответ факт из другой строки)
      if (matches[answer.id] == null && leftSlots[rowIndex] != null) {
        const toSave = leftSlots[rowIndex];
        // но если мы тащим именно его — он всё равно снимется removeFromOrigin
        if (toSave !== p.factId) {
          leftSlots[rowIndex] = null;
          returnFactToLeft(toSave);
        }
      }

      removeFromOrigin(p);
      matches[answer.id] = p.factId;

      render();
    });

    // mount row
    row.appendChild(leftNode);
    row.appendChild(gap);
    row.appendChild(rightTile);
    boardEl.appendChild(row);
  }

  updateButton();
}

// --- submit ---
submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map((a) => ({
    answerId: a.id,
    factId: matches[a.id] ?? null,
  }));
  console.log("submit:", result);
});

render();
Если хочешь, следующим шагом могу сделать ещё ближе к тому DOM:

добавить ту “картинку соединения” (Frame-2.svg) слева от каждой строки (как AnswerFeedback_image__...) — чисто декоративно;

сделать так, чтобы в правой карточке при совпадении появлялась тонкая граница/состояние “правильно/неправильно” (если у тебя есть correct mapping).

Вы сказали:
Загруженное изображение
Вот посмотри на картинку идавай попробуем проанализировать, что ты видишь и как понимаешь?
ChatGPT сказал:

Думал на протяжении 25s
Вижу вот что (по твоему скрину) и так это понимаю:

Что сейчас на экране
Есть две строки.

Строка 1: слева карточка «Факт 2», справа карточка «Ответ 1».

Строка 2: слева пустой слот (пунктирная рамка), справа карточка «Ответ 2».

Кнопка «Отправить» неактивна.

Как это выглядит с точки зрения логики/верстки
Связь “факт + ответ” не отображается как единый блок, хотя по идее ты ожидаешь, что “Факт 2” будет визуально склеен с “Ответ 1” (как одна длинная плашка).
Сейчас они выглядят как две отдельные карточки рядом, между ними заметный зазор — то есть “режим соединения” либо не включился, либо включился, но стили склейки не применились.

Появился пустой слот слева во второй строке.
Это обычно значит, что факт “ушёл” из одного места (например, перетащили из 2-й строки), но система оставила дыру.
А по твоему ожиданию (и по тому, как обычно делают в таких задачах) после перетаскивания:

либо не должно быть дыр (оставшиеся факты должны “подняться вверх” и занять пустое место),

либо пустой слот должен быть, но тогда должно быть понятно, что это “место для факта”, и при этом первая строка должна быть склеена (чтобы было ясно, что факт уже привязан к ответу).

Как я понимаю “как должно быть”
Когда факт сопоставлен с ответом, строка должна становиться “joined”: общий фон/единая плашка, внешние скругления, внутренние — без скругления, чтобы выглядело как “соединились”.

При этом список фактов слева (если это именно список “непривязанных”) должен быть без пустых дыр — оставшиеся факты сдвигаются.

Если ты согласен, то следующий шаг (без вопросов “а как ты хотел”) я сделаю так:

“joined” включается строго по matches[answerId] != null;

после любого дропа, который освобождает слот слева, делаем compact: убираем null из leftSlots и сдвигаем факты вверх (чтобы не было пустой строки).

Скажи только одно: пустые слоты слева вообще должны быть видны (как пунктир), или слева должен быть просто список фактов без слотов?
Я могу сделать оба варианта, но по твоему текущему скрину похоже, что ты хочешь именно без дыр.

Вы сказали:
Да я согласен с твоими размышлениями
ChatGPT сказал:

Думал на протяжении 50s
Отлично — тогда делаем 2 правки, которые прямо следуют из анализа:

Убираем “дыры” слева: после любого действия уплотняем leftSlots (все null уезжают вниз).

“Склейка” выглядит как одна длинная плашка: у строки в состоянии is-joined появляется общий фон на всю ширину (включая промежуток 24px), а две половины становятся прозрачными — остаются только внешние скругления.

Плюс маленькая, но важная штука: часто пользователь дропает “примерно на строку”, а не точно на правую карточку. Поэтому я добавил drop на всю строку: если дроп не на левый слот — считаем, что он на ответ этой строки.

Ниже — полные версии всех 3 файлов.

index.html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Сопоставление</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap">
    <h1 class="title">Сопоставление с обратной связью</h1>
    <p class="subtitle">
      Перетащите факт из левой колонки к соответствующему варианту в правой колонке.
    </p>

    <div class="board" id="board"></div>

    <button class="btn" id="submitBtn" type="button" disabled>Отправить</button>
  </div>

  <script src="app.js"></script>
</body>
</html>
styles.css
:root{
  --bg: #ffffff;
  --text: #0f172a;
  --muted: #64748b;

  --card: #e9ebef;
  --dash: #d6dae1;
  --ring: #3b82f6;

  --radius: 12px;
  --gap: 24px;
  --h: 64px;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

.wrap{
  max-width: 980px;
  margin: 36px auto;
  padding: 0 18px;
}

.title{
  margin: 0 0 10px 0;
  font-size: 28px;
  font-weight: 800;
}

.subtitle{
  margin: 0 0 22px 0;
  font-size: 16px;
  color: var(--muted);
}

.board{
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-bottom: 22px;
}

/* строка = left + gap + right */
.row{
  display:flex;
  align-items:stretch;
}

/* фиксированный промежуток как в DOM */
.gap{
  flex: 0 0 var(--gap);
}

/* карточки */
.tile{
  height: var(--h);
  min-height: var(--h);
  flex: 1 1 0;
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px 24px;
  display:flex;
  align-items:center;
  gap: 12px;
  overflow:hidden;
}

/* пустой слот слева */
.empty{
  height: var(--h);
  min-height: var(--h);
  flex: 1 1 0;
  border: 1.5px dashed var(--dash);
  border-radius: var(--radius);
  background: transparent;
}

/* draggable контент факта */
.fact{
  display:flex;
  align-items:center;
  gap: 12px;
  user-select:none;
  cursor: grab;
  width: 100%;
}
.fact:active{ cursor: grabbing; }

.grip{
  width: 18px;
  height: 18px;
  opacity: .55;
  flex: 0 0 auto;
}

/* подсветка drop зоны */
.drop-over{
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}
.dragging{ opacity: .75; }

/* ===== ВАЖНО: “склеенная” строка как одна длинная плашка =====
   Фон на всей строке, включая gap. Внутренние карточки прозрачные. */
.row.is-joined{
  background: var(--card);
  border-radius: var(--radius);
}

.row.is-joined .tile{
  background: transparent;
  border-radius: 0; /* скругления задаём только по внешним углам */
}

/* внешние углы */
.row.is-joined .tile.left{
  border-top-left-radius: var(--radius);
  border-bottom-left-radius: var(--radius);
}
.row.is-joined .tile.right{
  border-top-right-radius: var(--radius);
  border-bottom-right-radius: var(--radius);
}

/* кнопка */
.btn{
  background: #eef0f3;
  border: 0;
  border-radius: var(--radius);
  padding: 14px 22px;
  font-size: 16px;
  cursor:pointer;
}
.btn:disabled{
  opacity: .55;
  cursor: not-allowed;
}
.btn:not(:disabled):hover{
  filter: brightness(0.98);
}
app.js
// --- data ---
const FACTS = [
  { id: 1, text: "Факт 1" },
  { id: 2, text: "Факт 2" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

// --- state ---
// leftSlots[i] = factId | null
let leftSlots = Array.from({ length: ANSWERS.length }, (_, i) => FACTS[i]?.id ?? null);

// matches[answerId] = factId | null
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

// домашняя позиция факта (для красивого возврата при замене)
const homeIndexByFactId = new Map();
leftSlots.forEach((fid, idx) => {
  if (fid != null) homeIndexByFactId.set(fid, idx);
});

let dragPayload = null;
// payload: { factId, from:"left"|"match", leftIndex?:number, answerId?:number }

const boardEl = document.getElementById("board");
const submitBtn = document.getElementById("submitBtn");

// --- helpers ---
function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  `;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function removeFromOrigin(p) {
  if (!p) return;

  if (p.from === "left") {
    if (leftSlots[p.leftIndex] === p.factId) leftSlots[p.leftIndex] = null;
  } else if (p.from === "match") {
    if (matches[p.answerId] === p.factId) matches[p.answerId] = null;
  }
}

// УПЛОТНЕНИЕ: убираем дырки слева (null уезжают вниз)
function compactLeftSlots() {
  const filled = leftSlots.filter(x => x != null);
  const padded = filled.concat(Array(Math.max(0, ANSWERS.length - filled.length)).fill(null));
  leftSlots = padded.slice(0, ANSWERS.length);
}

function firstEmptyLeftIndex() {
  return leftSlots.findIndex(x => x === null);
}

function returnFactToLeft(factId, preferredIndex = -1) {
  // 1) предпочтительный слот
  if (preferredIndex >= 0 && leftSlots[preferredIndex] === null) {
    leftSlots[preferredIndex] = factId;
    return;
  }
  // 2) домашний слот
  const home = homeIndexByFactId.get(factId);
  if (home != null && leftSlots[home] === null) {
    leftSlots[home] = factId;
    return;
  }
  // 3) первый пустой
  const idx = firstEmptyLeftIndex();
  if (idx >= 0) leftSlots[idx] = factId;
}

function allMatched() {
  return ANSWERS.every(a => matches[a.id] != null);
}

function updateButton() {
  submitBtn.disabled = !allMatched();
}

// --- render nodes ---
function makeFactNode(factId, payload) {
  const f = FACTS.find(x => x.id === factId);

  const wrap = document.createElement("div");
  wrap.className = "fact";
  wrap.draggable = true;
  wrap.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  wrap.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    wrap.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  wrap.addEventListener("dragend", () => {
    wrap.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return wrap;
}

function attachDropHandlers(el, { onDrop }) {
  el.addEventListener("dragover", (e) => {
    e.preventDefault();
    clearOver();
    el.classList.add("drop-over");
  });
  el.addEventListener("dragleave", () => el.classList.remove("drop-over"));
  el.addEventListener("drop", (e) => {
    e.preventDefault();
    el.classList.remove("drop-over");
    const p = getPayload(e) ?? dragPayload;
    if (!p) return;
    onDrop(p);
  });
}

function assignToAnswer(answerId, rowIndex, payload) {
  // если ответ уже занят — старый факт вернуть в левую колонку
  const old = matches[answerId];
  if (old != null && old !== payload.factId) {
    matches[answerId] = null;
    returnFactToLeft(old, payload.from === "left" ? payload.leftIndex : -1);
  }

  // если мы тащим факт из left-колонки, и в этой строке слева тоже лежит какой-то факт,
  // он должен “освободиться” и уйти вниз (после compact)
  // ничего специально делать не нужно кроме того, что мы снимем источник removeFromOrigin.
  removeFromOrigin(payload);
  matches[answerId] = payload.factId;

  compactLeftSlots();
  render();
}

function render() {
  boardEl.innerHTML = "";

  for (let rowIndex = 0; rowIndex < ANSWERS.length; rowIndex++) {
    const answer = ANSWERS[rowIndex];
    const matchedFactId = matches[answer.id];

    const row = document.createElement("div");
    row.className = "row";
    row.dataset.answerId = String(answer.id);
    if (matchedFactId) row.classList.add("is-joined");

    // LEFT
    let leftNode;

    if (matchedFactId) {
      const leftTile = document.createElement("div");
      leftTile.className = "tile left";
      leftTile.appendChild(
        makeFactNode(matchedFactId, { from: "match", answerId: answer.id, factId: matchedFactId })
      );

      // drop на левую часть joined: замена факта в этом ответе
      attachDropHandlers(leftTile, {
        onDrop: (p) => {
          if (p.factId === matches[answer.id]) return;

          const old = matches[answer.id];
          if (old != null) {
            matches[answer.id] = null;
            returnFactToLeft(old, p.from === "left" ? p.leftIndex : -1);
          }

          removeFromOrigin(p);
          matches[answer.id] = p.factId;

          compactLeftSlots();
          render();
        }
      });

      leftNode = leftTile;
    } else {
      const factId = leftSlots[rowIndex];

      if (factId != null) {
        const leftTile = document.createElement("div");
        leftTile.className = "tile left";
        leftTile.appendChild(makeFactNode(factId, { from: "left", leftIndex: rowIndex, factId }));

        // drop на занятый слот = swap
        attachDropHandlers(leftTile, {
          onDrop: (p) => {
            const src = p.factId;
            const dst = leftSlots[rowIndex];
            if (src === dst) return;

            removeFromOrigin(p);
            leftSlots[rowIndex] = src;

            // вернуть то, что было здесь
            if (dst != null) {
              if (p.from === "left") {
                leftSlots[p.leftIndex] = dst;
              } else {
                returnFactToLeft(dst);
              }
            }

            compactLeftSlots();
            render();
          }
        });

        leftNode = leftTile;
      } else {
        const empty = document.createElement("div");
        empty.className = "empty left";

        // drop на пустой слот: вернуть факт в левую колонку
        attachDropHandlers(empty, {
          onDrop: (p) => {
            removeFromOrigin(p);
            leftSlots[rowIndex] = p.factId;

            compactLeftSlots();
            render();
          }
        });

        leftNode = empty;
      }
    }

    // GAP
    const gap = document.createElement("div");
    gap.className = "gap";

    // RIGHT
    const rightTile = document.createElement("div");
    rightTile.className = "tile right";
    rightTile.textContent = answer.text;

    // drop на правую карточку: назначаем
    attachDropHandlers(rightTile, {
      onDrop: (p) => assignToAnswer(answer.id, rowIndex, p)
    });

    // ВАЖНО: drop на всю строку (если попали в gap/фон/рядом),
    // но не перехватываем drop на левой части.
    row.addEventListener("dragover", (e) => {
      // если ведём над левой зоной — пусть работает её обработчик
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;
      e.preventDefault();
      clearOver();
      rightTile.classList.add("drop-over");
    });

    row.addEventListener("dragleave", (e) => {
      // убираем подсветку, когда уходим со строки
      if (!row.contains(e.relatedTarget)) {
        rightTile.classList.remove("drop-over");
      }
    });

    row.addEventListener("drop", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return; // левый сам обработает
      e.preventDefault();
      rightTile.classList.remove("drop-over");

      const p = getPayload(e) ?? dragPayload;
      if (!p) return;
      assignToAnswer(answer.id, rowIndex, p);
    });

    row.appendChild(leftNode);
    row.appendChild(gap);
    row.appendChild(rightTile);
    boardEl.appendChild(row);
  }

  updateButton();
}

// submit
submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map((a) => ({
    answerId: a.id,
    factId: matches[a.id] ?? null,
  }));
  console.log("submit:", result);
});

render();
Что поменяется у тебя на скрине после этих правок
После сопоставления факта с ответом строка станет одной длинной плашкой, а не “две отдельные карточки на белом”.

Пустой слот слева не будет “торчать в середине” — факты поднимутся вверх, дырка уедет вниз.

Можно кидать факт на всю строку справа, даже если попал в промежуток/фон.

Если после этого хочешь вообще без пустых слотов внизу (чтобы слева был “пул” без привязки к строкам) — скажи, я переведу на пул, но внешний вид строк останется таким же.

Вы сказали:
не плохо, даже отлично я бы сказал есть маленький баг, если например я выставил варианты а потом решил их поменять то взяв наприме вариант 1 и подтянув его на ответ 2( который уже соединен с вариантом 2) то вариант два пропадает. А он должен отсоединится и встать в пустое место для варинатов
ChatGPT сказал:

Думал на протяжении 1m 6s
Да, ты поймал реальный баг: при замене факта в уже “соединённом” ответе старый факт иногда “теряется”, потому что мы возвращаем старый факт в левую колонку ДО того, как освободили место (когда новый факт пришёл из left-слота). В итоге returnFactToLeft() не находит свободный слот и факт пропадает.

Фикс: сначала снять новый факт с его источника (removeFromOrigin), тем самым освободив слот слева, и только потом вернуть старый факт в этот освобождённый слот.

Ниже — переписанный app.js целиком (HTML/CSS оставь как есть из последней версии).

✅ Новый app.js
// --- data ---
const FACTS = [
  { id: 1, text: "Факт 1" },
  { id: 2, text: "Факт 2" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

// --- state ---
// leftSlots[i] = factId | null
let leftSlots = Array.from({ length: ANSWERS.length }, (_, i) => FACTS[i]?.id ?? null);

// matches[answerId] = factId | null
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

// домашняя позиция факта (для красивого возврата при замене)
const homeIndexByFactId = new Map();
leftSlots.forEach((fid, idx) => {
  if (fid != null) homeIndexByFactId.set(fid, idx);
});

let dragPayload = null;
// payload: { factId, from:"left"|"match", leftIndex?:number, answerId?:number }

const boardEl = document.getElementById("board");
const submitBtn = document.getElementById("submitBtn");

// --- helpers ---
function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  `;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function removeFromOrigin(p) {
  if (!p) return;

  if (p.from === "left") {
    if (leftSlots[p.leftIndex] === p.factId) leftSlots[p.leftIndex] = null;
  } else if (p.from === "match") {
    if (matches[p.answerId] === p.factId) matches[p.answerId] = null;
  }
}

// УПЛОТНЕНИЕ: убираем дырки слева (null уезжают вниз)
function compactLeftSlots() {
  const filled = leftSlots.filter(x => x != null);
  const padded = filled.concat(Array(Math.max(0, ANSWERS.length - filled.length)).fill(null));
  leftSlots = padded.slice(0, ANSWERS.length);
}

function firstEmptyLeftIndex() {
  return leftSlots.findIndex(x => x === null);
}

function returnFactToLeft(factId, preferredIndex = -1) {
  // 1) предпочтительный слот (обычно: тот, откуда факт пришёл)
  if (preferredIndex >= 0 && leftSlots[preferredIndex] === null) {
    leftSlots[preferredIndex] = factId;
    return;
  }
  // 2) домашний слот
  const home = homeIndexByFactId.get(factId);
  if (home != null && leftSlots[home] === null) {
    leftSlots[home] = factId;
    return;
  }
  // 3) первый пустой
  const idx = firstEmptyLeftIndex();
  if (idx >= 0) leftSlots[idx] = factId;
}

function allMatched() {
  return ANSWERS.every(a => matches[a.id] != null);
}

function updateButton() {
  submitBtn.disabled = !allMatched();
}

// === КЛЮЧЕВАЯ ФУНКЦИЯ (ФИКС) ===
// присвоить fact -> answer, если answer уже занят — старый факт возвращаем в leftSlots
function assignToAnswer(answerId, payload) {
  const current = matches[answerId];

  // если кидаем тот же факт туда же — ничего
  if (current != null && current === payload.factId) return;

  // 1) СНАЧАЛА снимаем новый факт с источника (освобождаем слот слева, если он оттуда)
  removeFromOrigin(payload);

  // 2) Если в ответе был старый факт — вернуть его в левую колонку
  if (current != null) {
    matches[answerId] = null; // снять старый
    const preferred = payload.from === "left" ? payload.leftIndex : -1;
    returnFactToLeft(current, preferred);
  }

  // 3) Поставить новый
  matches[answerId] = payload.factId;

  // 4) Уплотнить левую колонку (без дыр)
  compactLeftSlots();

  render();
}

function attachDropHandlers(el, { onDrop }) {
  el.addEventListener("dragover", (e) => {
    e.preventDefault();
    clearOver();
    el.classList.add("drop-over");
  });
  el.addEventListener("dragleave", () => el.classList.remove("drop-over"));
  el.addEventListener("drop", (e) => {
    e.preventDefault();
    el.classList.remove("drop-over");
    const p = getPayload(e) ?? dragPayload;
    if (!p) return;
    onDrop(p);
  });
}

// --- render nodes ---
function makeFactNode(factId, payload) {
  const f = FACTS.find(x => x.id === factId);

  const wrap = document.createElement("div");
  wrap.className = "fact";
  wrap.draggable = true;
  wrap.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  wrap.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    wrap.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  wrap.addEventListener("dragend", () => {
    wrap.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return wrap;
}

function render() {
  boardEl.innerHTML = "";

  for (let rowIndex = 0; rowIndex < ANSWERS.length; rowIndex++) {
    const answer = ANSWERS[rowIndex];
    const matchedFactId = matches[answer.id];

    const row = document.createElement("div");
    row.className = "row";
    row.dataset.answerId = String(answer.id);
    if (matchedFactId) row.classList.add("is-joined");

    // LEFT
    let leftNode;

    if (matchedFactId) {
      // joined: слева факт (можно перетащить/заменить)
      const leftTile = document.createElement("div");
      leftTile.className = "tile left";
      leftTile.appendChild(
        makeFactNode(matchedFactId, { from: "match", answerId: answer.id, factId: matchedFactId })
      );

      // drop на левую часть joined = тоже "назначить" (замена)
      attachDropHandlers(leftTile, {
        onDrop: (p) => assignToAnswer(answer.id, p)
      });

      leftNode = leftTile;
    } else {
      const factId = leftSlots[rowIndex];

      if (factId != null) {
        const leftTile = document.createElement("div");
        leftTile.className = "tile left";
        leftTile.appendChild(makeFactNode(factId, { from: "left", leftIndex: rowIndex, factId }));

        // drop на занятый слот = swap
        attachDropHandlers(leftTile, {
          onDrop: (p) => {
            const src = p.factId;
            const dst = leftSlots[rowIndex];
            if (src === dst) return;

            removeFromOrigin(p);
            leftSlots[rowIndex] = src;

            // вернуть то, что было здесь
            if (dst != null) {
              if (p.from === "left") {
                leftSlots[p.leftIndex] = dst;
              } else {
                returnFactToLeft(dst);
              }
            }

            compactLeftSlots();
            render();
          }
        });

        leftNode = leftTile;
      } else {
        const empty = document.createElement("div");
        empty.className = "empty left";

        // drop на пустой слот: вернуть факт в левую колонку
        attachDropHandlers(empty, {
          onDrop: (p) => {
            removeFromOrigin(p);
            leftSlots[rowIndex] = p.factId;

            compactLeftSlots();
            render();
          }
        });

        leftNode = empty;
      }
    }

    // GAP
    const gap = document.createElement("div");
    gap.className = "gap";

    // RIGHT (answer)
    const rightTile = document.createElement("div");
    rightTile.className = "tile right";
    rightTile.textContent = answer.text;

    // drop на ответ: назначить
    attachDropHandlers(rightTile, {
      onDrop: (p) => assignToAnswer(answer.id, p)
    });

    // drop на всю строку (если попали в gap/фон), но не перехватываем drop на left
    row.addEventListener("dragover", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;
      e.preventDefault();
      clearOver();
      rightTile.classList.add("drop-over");
    });

    row.addEventListener("dragleave", (e) => {
      if (!row.contains(e.relatedTarget)) {
        rightTile.classList.remove("drop-over");
      }
    });

    row.addEventListener("drop", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;

      e.preventDefault();
      rightTile.classList.remove("drop-over");

      const p = getPayload(e) ?? dragPayload;
      if (!p) return;
      assignToAnswer(answer.id, p);
    });

    row.appendChild(leftNode);
    row.appendChild(gap);
    row.appendChild(rightTile);
    boardEl.appendChild(row);
  }

  updateButton();
}

// submit
submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map((a) => ({
    answerId: a.id,
    factId: matches[a.id] ?? null,
  }));
  console.log("submit:", result);
});

render();
Что теперь будет в твоём сценарии
Если у тебя уже:

Ответ 1 ↔ Факт 1

Ответ 2 ↔ Факт 2

и ты перетаскиваешь Факт 1 на Ответ 2, то:

Ответ 2 получит Факт 1

Факт 2 автоматически “отсоединится” и появится слева (в свободном месте, которое освобождается корректно)

Если поймаешь ещё крайний кейс (например 5–10 строк) — кидай скрин/описание, допилим до идеала.

Вы сказали:
Загруженное изображение
Странно но как только я перетаскиваю верхний элементсразу нижний исчезает
ChatGPT сказал:

Думал на протяжении 2m 9s
Да, это ровно тот эффект, который появляется из-за нашей “уплотнялки” слева:

ты сопоставляешь первую строку → она становится joined и левый слот этой строки больше не рисуется (там уже стоит “привязанный факт”).

мы при этом “уплотняем” leftSlots и сдвигаем оставшиеся факты наверх, и второй факт переезжает в индекс 0… который теперь не виден, потому что строка 0 уже joined.

визуально кажется, что “нижний исчез”.

✅ Правильная модель как в таких интерфейсах: левые факты — это пул “непривязанных”, который раскладывается только по незаполненным строкам. Тогда ничего не пропадает.

Ниже — полностью новый app.js (HTML и CSS оставь как у тебя сейчас из последней версии).

✅ Заменить app.js целиком
// --- data ---
const FACTS = [
  { id: 1, text: "Факт 1" },
  { id: 2, text: "Факт 2" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

// --- state ---
// pool = список НЕпривязанных фактов (порядок важен)
let pool = FACTS.map(f => f.id);

// matches[answerId] = factId | null
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

let dragPayload = null;
// payload: { factId, from:"pool"|"match", poolIndex?:number, answerId?:number }

const boardEl = document.getElementById("board");
const submitBtn = document.getElementById("submitBtn");

// --- helpers ---
function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  `;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function removeFromPoolById(factId, hintIndex = null) {
  if (hintIndex != null && pool[hintIndex] === factId) {
    pool.splice(hintIndex, 1);
    return hintIndex;
  }
  const idx = pool.indexOf(factId);
  if (idx >= 0) {
    pool.splice(idx, 1);
    return idx;
  }
  return -1;
}

function insertIntoPoolAt(factId, index) {
  const i = Math.max(0, Math.min(index, pool.length));
  pool.splice(i, 0, factId);
}

function removeFromOrigin(p) {
  if (!p) return;

  if (p.from === "pool") {
    removeFromPoolById(p.factId, p.poolIndex ?? null);
  } else if (p.from === "match") {
    if (matches[p.answerId] === p.factId) matches[p.answerId] = null;
  }
}

function unmatchedRowIndices() {
  const res = [];
  for (let i = 0; i < ANSWERS.length; i++) {
    const a = ANSWERS[i];
    if (matches[a.id] == null) res.push(i);
  }
  return res;
}

function slotIndexForRow(rowIndex) {
  // индекс слота в пуле для конкретной НЕзаполненной строки
  const rows = unmatchedRowIndices();
  return rows.indexOf(rowIndex); // -1 если строка уже matched
}

function allMatched() {
  return ANSWERS.every(a => matches[a.id] != null);
}

function updateButton() {
  submitBtn.disabled = !allMatched();
}

// --- core actions ---
function assignToAnswer(answerId, payload) {
  const current = matches[answerId];

  if (current != null && current === payload.factId) return;

  // 1) снимаем новый факт с источника
  removeFromOrigin(payload);

  // 2) если тут был старый факт — вернуть его в пул
  if (current != null) {
    // если новый пришёл из пула — вернуть старый на то же место
    if (payload.from === "pool" && payload.poolIndex != null) {
      insertIntoPoolAt(current, payload.poolIndex);
    } else {
      pool.push(current);
    }
  }

  // 3) назначаем новый
  matches[answerId] = payload.factId;

  render();
}

function dropToPoolRow(targetRowIndex, payload) {
  // дропнули на левую колонку в конкретную строку (только если она не matched)
  const targetSlotIndex = slotIndexForRow(targetRowIndex);
  if (targetSlotIndex < 0) return; // строка уже matched

  // если цель занята (есть факт в пуле на этом слоте) и тащим из пула — сделаем swap
  const targetFactId = pool[targetSlotIndex] ?? null;

  if (payload.from === "pool") {
    // swap логика
    const srcIndex = removeFromPoolById(payload.factId, payload.poolIndex ?? null);

    // после удаления индексы могли сдвинуться
    let adjustedTarget = targetSlotIndex;
    if (srcIndex >= 0 && srcIndex < targetSlotIndex) adjustedTarget = targetSlotIndex - 1;

    if (targetFactId != null) {
      // вытащить target из пула
      const tIdx = pool.indexOf(targetFactId);
      if (tIdx >= 0) pool.splice(tIdx, 1);

      // вставить src на место цели
      insertIntoPoolAt(payload.factId, adjustedTarget);

      // вернуть target на место src (примерно)
      const backIndex = srcIndex >= 0 ? Math.min(srcIndex, pool.length) : pool.length;
      insertIntoPoolAt(targetFactId, backIndex);
    } else {
      // просто вставка
      insertIntoPoolAt(payload.factId, adjustedTarget);
    }
  } else {
    // из match: просто снять и вставить в пул
    removeFromOrigin(payload);

    // если цель занята — просто вставим перед ней (нормально)
    insertIntoPoolAt(payload.factId, targetSlotIndex);
  }

  render();
}

// --- render ---
function makeFactNode(factId, payload) {
  const f = FACTS.find(x => x.id === factId);

  const wrap = document.createElement("div");
  wrap.className = "fact";
  wrap.draggable = true;
  wrap.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  wrap.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    wrap.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  wrap.addEventListener("dragend", () => {
    wrap.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return wrap;
}

function attachDropHandlers(el, { onDrop }) {
  el.addEventListener("dragover", (e) => {
    e.preventDefault();
    clearOver();
    el.classList.add("drop-over");
  });
  el.addEventListener("dragleave", () => el.classList.remove("drop-over"));
  el.addEventListener("drop", (e) => {
    e.preventDefault();
    el.classList.remove("drop-over");
    const p = getPayload(e) ?? dragPayload;
    if (!p) return;
    onDrop(p);
  });
}

function render() {
  boardEl.innerHTML = "";

  const rowsUnmatched = unmatchedRowIndices();

  for (let rowIndex = 0; rowIndex < ANSWERS.length; rowIndex++) {
    const answer = ANSWERS[rowIndex];
    const matchedFactId = matches[answer.id];

    const row = document.createElement("div");
    row.className = "row";
    row.dataset.answerId = String(answer.id);
    if (matchedFactId) row.classList.add("is-joined");

    // LEFT
    let leftNode;

    if (matchedFactId) {
      const leftTile = document.createElement("div");
      leftTile.className = "tile left";
      leftTile.appendChild(
        makeFactNode(matchedFactId, { from: "match", answerId: answer.id, factId: matchedFactId })
      );

      // дроп на joined-left = замена (назначение этому же ответу)
      attachDropHandlers(leftTile, {
        onDrop: (p) => assignToAnswer(answer.id, p)
      });

      leftNode = leftTile;
    } else {
      // строка не matched => слева показываем элемент из pool по slotIndex
      const slotIndex = rowsUnmatched.indexOf(rowIndex);
      const factId = pool[slotIndex] ?? null;

      if (factId != null) {
        const leftTile = document.createElement("div");
        leftTile.className = "tile left";
        leftTile.appendChild(
          makeFactNode(factId, { from: "pool", poolIndex: slotIndex, factId })
        );

        // дроп на занятый слот => swap/вставка
        attachDropHandlers(leftTile, {
          onDrop: (p) => dropToPoolRow(rowIndex, p)
        });

        leftNode = leftTile;
      } else {
        const empty = document.createElement("div");
        empty.className = "empty left";

        // дроп на пустой слот => вернуть факт в пул сюда
        attachDropHandlers(empty, {
          onDrop: (p) => dropToPoolRow(rowIndex, p)
        });

        leftNode = empty;
      }
    }

    // GAP
    const gap = document.createElement("div");
    gap.className = "gap";

    // RIGHT (answer)
    const rightTile = document.createElement("div");
    rightTile.className = "tile right";
    rightTile.textContent = answer.text;

    attachDropHandlers(rightTile, {
      onDrop: (p) => assignToAnswer(answer.id, p)
    });

    // drop на всю строку (gap/фон) => как будто на ответ, но не перехватываем left
    row.addEventListener("dragover", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;
      e.preventDefault();
      clearOver();
      rightTile.classList.add("drop-over");
    });

    row.addEventListener("dragleave", (e) => {
      if (!row.contains(e.relatedTarget)) rightTile.classList.remove("drop-over");
    });

    row.addEventListener("drop", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;

      e.preventDefault();
      rightTile.classList.remove("drop-over");

      const p = getPayload(e) ?? dragPayload;
      if (!p) return;
      assignToAnswer(answer.id, p);
    });

    row.appendChild(leftNode);
    row.appendChild(gap);
    row.appendChild(rightTile);
    boardEl.appendChild(row);
  }

  updateButton();
}

// submit
submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map(a => ({
    answerId: a.id,
    factId: matches[a.id] ?? null,
  }));
  console.log("submit:", result);
});

render();
Что это исправляет
Как только верхний факт “привязался” и строка стала joined, оставшиеся факты не переезжают в “скрытую” строку, а показываются в следующей незаполненной строке.

При замене (перетащил факт на уже занятый ответ) старый факт возвращается в пул и не исчезает.

Если хочешь — следующим шагом добавлю правильное поведение “swap” и для matched↔matched (когда таскаешь факт из Ответ1 на Ответ2 — чтобы они именно менялись местами), но текущая версия уже не должна терять элементы.

Вы сказали:
и так отлично но есть маленькое но у нас фиксирован размер контейнеров а надо чтобы он подстраивался под самый большой текст при чем все контейнеры должны быть одинаковыми
ChatGPT сказал:

Думал на протяжении 19s
Понял: высота карточек должна быть авто под самый большой текст, и все карточки (и слева, и справа, во всех строках) должны стать одинаковой высоты, равной максимальной.

Чистым CSS это не сделать “глобально по всем строкам” (CSS выравнивает только внутри одной строки), поэтому делаем как обычно в таких UI:

рендерим карточки с height: auto

измеряем максимальную высоту среди .tile и .empty

записываем её в CSS-переменную --tileH

применяем height: var(--tileH) ко всем карточкам

пересчитываем при resize

Ниже — переписанные целиком styles.css и app.js. index.html оставь как есть (последний рабочий).

styles.css (целиком)
:root{
  --bg: #ffffff;
  --text: #0f172a;
  --muted: #64748b;

  --card: #e9ebef;
  --dash: #d6dae1;
  --ring: #3b82f6;

  --radius: 12px;
  --gap: 24px;

  /* будет выставляться JS */
  --tileH: auto;
}

*{ box-sizing:border-box; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

.wrap{
  max-width: 980px;
  margin: 36px auto;
  padding: 0 18px;
}

.title{
  margin: 0 0 10px 0;
  font-size: 28px;
  font-weight: 800;
}

.subtitle{
  margin: 0 0 22px 0;
  font-size: 16px;
  color: var(--muted);
}

.board{
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-bottom: 22px;
}

/* строка = left + gap + right */
.row{
  display:flex;
  align-items:stretch;
}

/* фиксированный промежуток как в DOM */
.gap{
  flex: 0 0 var(--gap);
}

/* карточки */
.tile{
  flex: 1 1 0;
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px 24px;

  display:flex;
  align-items:center;
  gap: 12px;

  /* важно для автоподбора высоты */
  height: var(--tileH);
  overflow: hidden;
}

/* пустой слот слева */
.empty{
  flex: 1 1 0;
  border: 1.5px dashed var(--dash);
  border-radius: var(--radius);
  background: transparent;

  height: var(--tileH);
}

/* draggable контент факта */
.fact{
  display:flex;
  align-items:center;
  gap: 12px;
  user-select:none;
  cursor: grab;

  width: 100%;
  min-width: 0;
}
.fact:active{ cursor: grabbing; }

.fact span{
  display:block;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap; /* как в большинстве matching */
}

.grip{
  width: 18px;
  height: 18px;
  opacity: .55;
  flex: 0 0 auto;
}

/* подсветка drop зоны */
.drop-over{
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}
.dragging{ opacity: .75; }

/* ===== “склеенная” строка как одна длинная плашка ===== */
.row.is-joined{
  background: var(--card);
  border-radius: var(--radius);
}

.row.is-joined .tile{
  background: transparent;
  border-radius: 0;
}

.row.is-joined .tile.left{
  border-top-left-radius: var(--radius);
  border-bottom-left-radius: var(--radius);
}
.row.is-joined .tile.right{
  border-top-right-radius: var(--radius);
  border-bottom-right-radius: var(--radius);
}

/* кнопка */
.btn{
  background: #eef0f3;
  border: 0;
  border-radius: var(--radius);
  padding: 14px 22px;
  font-size: 16px;
  cursor:pointer;
}
.btn:disabled{
  opacity: .55;
  cursor: not-allowed;
}
.btn:not(:disabled):hover{
  filter: brightness(0.98);
}
app.js (целиком)
// --- data ---
const FACTS = [
  { id: 1, text: "Факт 1" },
  { id: 2, text: "Факт 2" },
];

const ANSWERS = [
  { id: 101, text: "Ответ 1" },
  { id: 102, text: "Ответ 2" },
];

// --- state ---
// pool = список НЕпривязанных фактов
let pool = FACTS.map(f => f.id);

// matches[answerId] = factId | null
let matches = Object.fromEntries(ANSWERS.map(a => [a.id, null]));

let dragPayload = null;
// payload: { factId, from:"pool"|"match", poolIndex?:number, answerId?:number }

const boardEl = document.getElementById("board");
const submitBtn = document.getElementById("submitBtn");

function gripSvg() {
  return `
    <svg class="grip" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  `;
}

function clearOver() {
  document.querySelectorAll(".drop-over").forEach(el => el.classList.remove("drop-over"));
}

function getPayload(e) {
  try {
    const raw = e.dataTransfer.getData("application/json");
    if (!raw) return null;
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function removeFromPoolById(factId, hintIndex = null) {
  if (hintIndex != null && pool[hintIndex] === factId) {
    pool.splice(hintIndex, 1);
    return hintIndex;
  }
  const idx = pool.indexOf(factId);
  if (idx >= 0) {
    pool.splice(idx, 1);
    return idx;
  }
  return -1;
}

function insertIntoPoolAt(factId, index) {
  const i = Math.max(0, Math.min(index, pool.length));
  pool.splice(i, 0, factId);
}

function removeFromOrigin(p) {
  if (!p) return;
  if (p.from === "pool") {
    removeFromPoolById(p.factId, p.poolIndex ?? null);
  } else if (p.from === "match") {
    if (matches[p.answerId] === p.factId) matches[p.answerId] = null;
  }
}

function unmatchedRowIndices() {
  const res = [];
  for (let i = 0; i < ANSWERS.length; i++) {
    const a = ANSWERS[i];
    if (matches[a.id] == null) res.push(i);
  }
  return res;
}

function slotIndexForRow(rowIndex) {
  const rows = unmatchedRowIndices();
  return rows.indexOf(rowIndex); // -1 если строка уже matched
}

function allMatched() {
  return ANSWERS.every(a => matches[a.id] != null);
}

function updateButton() {
  submitBtn.disabled = !allMatched();
}

// === высота карточек: равняем по самому большому ===
let heightRAF = 0;

function resetTileHeightToAuto() {
  document.documentElement.style.setProperty("--tileH", "auto");
}

function syncTileHeights() {
  cancelAnimationFrame(heightRAF);
  heightRAF = requestAnimationFrame(() => {
    resetTileHeightToAuto();

    // измеряем после того как browser применил auto
    requestAnimationFrame(() => {
      const nodes = boardEl.querySelectorAll(".tile, .empty");
      let maxH = 0;

      nodes.forEach(n => {
        const h = n.offsetHeight;
        if (h > maxH) maxH = h;
      });

      // небольшой safety-минимум, если вдруг ничего
      if (maxH < 40) maxH = 64;

      document.documentElement.style.setProperty("--tileH", `${maxH}px`);
    });
  });
}

// --- core actions ---
function assignToAnswer(answerId, payload) {
  const current = matches[answerId];
  if (current != null && current === payload.factId) return;

  // 1) снимаем новый факт с источника
  removeFromOrigin(payload);

  // 2) если тут был старый факт — вернуть его в пул
  if (current != null) {
    if (payload.from === "pool" && payload.poolIndex != null) {
      insertIntoPoolAt(current, payload.poolIndex);
    } else {
      pool.push(current);
    }
  }

  // 3) назначаем новый
  matches[answerId] = payload.factId;

  render();
}

function dropToPoolRow(targetRowIndex, payload) {
  const targetSlotIndex = slotIndexForRow(targetRowIndex);
  if (targetSlotIndex < 0) return;

  const targetFactId = pool[targetSlotIndex] ?? null;

  if (payload.from === "pool") {
    const srcIndex = removeFromPoolById(payload.factId, payload.poolIndex ?? null);

    let adjustedTarget = targetSlotIndex;
    if (srcIndex >= 0 && srcIndex < targetSlotIndex) adjustedTarget = targetSlotIndex - 1;

    if (targetFactId != null) {
      const tIdx = pool.indexOf(targetFactId);
      if (tIdx >= 0) pool.splice(tIdx, 1);

      insertIntoPoolAt(payload.factId, adjustedTarget);

      const backIndex = srcIndex >= 0 ? Math.min(srcIndex, pool.length) : pool.length;
      insertIntoPoolAt(targetFactId, backIndex);
    } else {
      insertIntoPoolAt(payload.factId, adjustedTarget);
    }
  } else {
    removeFromOrigin(payload);
    insertIntoPoolAt(payload.factId, targetSlotIndex);
  }

  render();
}

// --- render ---
function makeFactNode(factId, payload) {
  const f = FACTS.find(x => x.id === factId);

  const wrap = document.createElement("div");
  wrap.className = "fact";
  wrap.draggable = true;
  wrap.innerHTML = `${gripSvg()}<span>${f ? f.text : ("#" + factId)}</span>`;

  wrap.addEventListener("dragstart", (e) => {
    dragPayload = payload;
    wrap.classList.add("dragging");
    try {
      e.dataTransfer.setData("application/json", JSON.stringify(payload));
      e.dataTransfer.effectAllowed = "move";
    } catch {}
  });

  wrap.addEventListener("dragend", () => {
    wrap.classList.remove("dragging");
    dragPayload = null;
    clearOver();
  });

  return wrap;
}

function attachDropHandlers(el, { onDrop }) {
  el.addEventListener("dragover", (e) => {
    e.preventDefault();
    clearOver();
    el.classList.add("drop-over");
  });
  el.addEventListener("dragleave", () => el.classList.remove("drop-over"));
  el.addEventListener("drop", (e) => {
    e.preventDefault();
    el.classList.remove("drop-over");
    const p = getPayload(e) ?? dragPayload;
    if (!p) return;
    onDrop(p);
  });
}

function render() {
  boardEl.innerHTML = "";

  const rowsUnmatched = unmatchedRowIndices();

  for (let rowIndex = 0; rowIndex < ANSWERS.length; rowIndex++) {
    const answer = ANSWERS[rowIndex];
    const matchedFactId = matches[answer.id];

    const row = document.createElement("div");
    row.className = "row";
    row.dataset.answerId = String(answer.id);
    if (matchedFactId) row.classList.add("is-joined");

    // LEFT
    let leftNode;

    if (matchedFactId) {
      const leftTile = document.createElement("div");
      leftTile.className = "tile left";
      leftTile.appendChild(
        makeFactNode(matchedFactId, { from: "match", answerId: answer.id, factId: matchedFactId })
      );

      attachDropHandlers(leftTile, {
        onDrop: (p) => assignToAnswer(answer.id, p)
      });

      leftNode = leftTile;
    } else {
      const slotIndex = rowsUnmatched.indexOf(rowIndex);
      const factId = pool[slotIndex] ?? null;

      if (factId != null) {
        const leftTile = document.createElement("div");
        leftTile.className = "tile left";
        leftTile.appendChild(
          makeFactNode(factId, { from: "pool", poolIndex: slotIndex, factId })
        );

        attachDropHandlers(leftTile, {
          onDrop: (p) => dropToPoolRow(rowIndex, p)
        });

        leftNode = leftTile;
      } else {
        const empty = document.createElement("div");
        empty.className = "empty left";

        attachDropHandlers(empty, {
          onDrop: (p) => dropToPoolRow(rowIndex, p)
        });

        leftNode = empty;
      }
    }

    // GAP
    const gap = document.createElement("div");
    gap.className = "gap";

    // RIGHT
    const rightTile = document.createElement("div");
    rightTile.className = "tile right";
    rightTile.textContent = answer.text;

    attachDropHandlers(rightTile, {
      onDrop: (p) => assignToAnswer(answer.id, p)
    });

    // drop на всю строку (gap/фон), но не перехватываем left
    row.addEventListener("dragover", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;
      e.preventDefault();
      clearOver();
      rightTile.classList.add("drop-over");
    });

    row.addEventListener("dragleave", (e) => {
      if (!row.contains(e.relatedTarget)) rightTile.classList.remove("drop-over");
    });

    row.addEventListener("drop", (e) => {
      const overLeft = e.target.closest?.(".left");
      if (overLeft) return;

      e.preventDefault();
      rightTile.classList.remove("drop-over");

      const p = getPayload(e) ?? dragPayload;
      if (!p) return;
      assignToAnswer(answer.id, p);
    });

    row.appendChild(leftNode);
    row.appendChild(gap);
    row.appendChild(rightTile);
    boardEl.appendChild(row);
  }

  updateButton();
  syncTileHeights();
}

// submit
submitBtn.addEventListener("click", () => {
  const result = ANSWERS.map(a => ({
    answerId: a.id,
    factId: matches[a.id] ?? null,
  }));
  console.log("submit:", result);
});

// пересчёт при ресайзе/переносах строк
window.addEventListener("resize", () => syncTileHeights());

// init
render();
Что получится
Карточки будут расти по самому большому тексту (в любой строке/колонке).

И все карточки станут одинаковой высоты (и пустые слоты тоже).

При изменении ширины окна (текст может переноситься) высота пересчитается автоматически.

Если хочешь, чтобы текст не обрезался троеточием, а переносился на 2–3 строки — скажи, поменяю white-space: nowrap на перенос и ограничение строк.

Вы сказали:
scorm-exporter.ts
TypeScript
Отлично давай теперь попробуем сделать тоже самое только для моего кода

Вот мой код соответсвенно нам нужно в моей стилистике, блок называется MATCHING
ChatGPT сказал:

Думал на протяжении 13m 58s
Ок, понял задачу: в MATCHING нужен “склеенный” ряд (левый вариант + правый ответ в одной плашке), нормальная перестановка (чтобы вытесненный вариант не исчезал), и авто-высота по самому длинному тексту (все строки одинаковой высоты).

Я адаптировал это прямо под твой код в scorm-exporter.ts (блок MATCHING):

добавил state.matchingPools (пул с порядком вариантов, чтобы при замене “старый” вставал в освободившееся место),

полностью переписал рендер MATCHING под формат “как на картинке” (строка = левый слот + gap + правый ответ, при совпадении склеиваются),

переписал DnD-логику, чтобы:

при перетаскивании варианта на занятый ответ старый вариант возвращался в пул (в правильное место),

можно было перетаскивать вариант назад в левую пустую ячейку,

всё работало через render() (никаких “пропаданий” из-за DOM-мутаций),

сделал авто-высоту через syncMatchingHeights() (меряет максимум и ставит всем одинаковую высоту через CSS-переменную).

📄 Готовый файл:
Download scorm-exporter.patched.ts

Если хочешь — можешь просто заменить свой scorm-exporter.ts на этот, либо я могу следующим шагом сделать “diff по кускам” (что именно заменить), но файл уже полностью рабочий.

Вы сказали:
выведи код здесь, важно покажи какие функции на что меняем или что именно где добавить
ChatGPT сказал:

Думал на протяжении 3m 41s
Ок — давай “перенесём” нашу логику в твой SCORM-код. Ниже покажу точечно: что заменить / что добавить / где внутри scorm-exporter.ts (внутри строки, которую возвращает buildAppJs() и buildStylesCss()).

1) buildAppJs() — правим window.onload + добавляем syncMatchingHeights()
✅ ЗАМЕНИ window.onload = function() { ... } на это:
window.onload = function() {
  SCORM.init();
  window.addEventListener('beforeunload', function() {
    try { SCORM.commit(); } catch (e) {}
    try { SCORM.terminate(); } catch (e) {}
  });
  bindRankingClicksOnce();
  bindMatchingDnDOnce();
  generateVariant();
  render();
  window.addEventListener('resize', function(){ syncMatchingHeights(); });
};
✅ СРАЗУ ПЕРЕД function bindMatchingDnDOnce() добавь:
var __matchHeightRAF = 0;
function syncMatchingHeights() {
  try {
    if (__matchHeightRAF) cancelAnimationFrame(__matchHeightRAF);
  } catch (e) {}

  __matchHeightRAF = requestAnimationFrame(function() {
    var roots = document.querySelectorAll('.matching-board');
    for (var i = 0; i < roots.length; i++) {
      var root = roots[i];
      if (!root || !root.style) continue;

      // reset to auto for measurement
      root.style.setProperty('--matchRowH', 'auto');

      // measure after next frame so layout is updated
      (function(r) {
        requestAnimationFrame(function() {
          var nodes = r.querySelectorAll('.match-tile, .match-empty');
          var maxH = 0;
          for (var j = 0; j < nodes.length; j++) {
            var h = nodes[j].offsetHeight || 0;
            if (h > maxH) maxH = h;
          }
          if (maxH < 44) maxH = 56; // safety
          r.style.setProperty('--matchRowH', String(maxH) + 'px');
        });
      })(root);
    }
  });
}
✅ В КОНЦЕ function render() (после app.innerHTML = html;) добавь:
syncMatchingHeights();
2) buildAppJs() — ПОЛНОСТЬЮ заменить bindMatchingDnDOnce()
Найди твою старую function bindMatchingDnDOnce() { ... } (где DOM перекидывается между .matching-pool и .slot-drop) и замени всю функцию целиком на эту:

function bindMatchingDnDOnce() {
  if (__matchDndBound) return;
  __matchDndBound = true;

  function closestByClass(node, cls) {
    var el = node;
    while (el && el !== document) {
      if (el.classList && el.classList.contains(cls)) return el;
      el = el.parentNode;
    }
    return null;
  }

  function parsePayloadFromEvent(e) {
    var raw = '';
    try { raw = e.dataTransfer.getData('application/json'); } catch (err) {}
    if (!raw) {
      try { raw = e.dataTransfer.getData('text/plain'); } catch (err2) {}
    }
    if (!raw) return null;

    // JSON first
    try {
      var obj = JSON.parse(raw);
      if (obj && obj.qid) return obj;
    } catch (e1) {}

    // fallback: qid|leftIdx|from|poolIndex|rightIdx
    var parts = String(raw).split('|');
    if (parts.length < 2) return null;

    var qid = parts[0];
    var leftIdx = parseInt(parts[1], 10);
    if (!qid || Number.isNaN(leftIdx)) return null;

    var payload = { qid: qid, leftIdx: leftIdx, from: parts[2] || 'pool' };
    if (parts[3]) {
      var pi = parseInt(parts[3], 10);
      if (!Number.isNaN(pi)) payload.poolIndex = pi;
    }
    if (parts[4]) {
      var ri = parseInt(parts[4], 10);
      if (!Number.isNaN(ri)) payload.rightIdx = ri;
    }
    return payload;
  }

  function getCurrentQuestionById(qid) {
    var current = state.flatQuestions[state.currentIndex] && state.flatQuestions[state.currentIndex].question;
    if (current && String(current.id) === String(qid)) return current;

    for (var i = 0; i < state.flatQuestions.length; i++) {
      var q = state.flatQuestions[i].question;
      if (q && String(q.id) === String(qid)) return q;
    }
    return null;
  }

  function normalizePool(qid, leftMapping, ans) {
    if (!state.matchingPools) state.matchingPools = {};
    if (!Array.isArray(state.matchingPools[qid])) state.matchingPools[qid] = leftMapping.slice();

    var pool = state.matchingPools[qid];

    // used left
    var used = {};
    Object.keys(ans || {}).forEach(function(k) {
      var li = parseInt(k, 10);
      if (!Number.isNaN(li)) used[li] = true;
    });

    // remove used from pool
    var next = [];
    for (var i = 0; i < pool.length; i++) {
      var li2 = pool[i];
      if (!used[li2]) next.push(li2);
    }

    // add missing unused in leftMapping order
    for (var j = 0; j < leftMapping.length; j++) {
      var li3 = leftMapping[j];
      if (used[li3]) continue;
      if (next.indexOf(li3) === -1) next.push(li3);
    }

    state.matchingPools[qid] = next;
    return next;
  }

  function removeFromPool(pool, leftIdx, poolIndex) {
    if (!Array.isArray(pool)) return -1;

    if (typeof poolIndex === 'number' && poolIndex >= 0 && poolIndex < pool.length && pool[poolIndex] === leftIdx) {
      pool.splice(poolIndex, 1);
      return poolIndex;
    }

    var idx = pool.indexOf(leftIdx);
    if (idx >= 0) {
      pool.splice(idx, 1);
      return idx;
    }

    return -1;
  }

  function insertIntoPool(pool, leftIdx, index) {
    if (!Array.isArray(pool)) return;
    var i = (typeof index === 'number') ? index : pool.length;
    if (i < 0) i = 0;
    if (i > pool.length) i = pool.length;
    pool.splice(i, 0, leftIdx);
  }

  function leftForRight(ans, rightIdx) {
    var keys = Object.keys(ans || {});
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (ans[k] === rightIdx) return parseInt(k, 10);
    }
    return null;
  }

  function removeLeftFromAnswers(ans, leftIdx) {
    if (!ans || typeof ans !== 'object') return;
    if (ans.hasOwnProperty(leftIdx)) delete ans[leftIdx];
    if (ans.hasOwnProperty(String(leftIdx))) delete ans[String(leftIdx)];
  }

  // dragstart
  document.addEventListener('dragstart', function(e) {
    var card = closestByClass(e.target, 'match-chip');
    if (!card) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
      e.preventDefault();
      return;
    }

    var qid = card.getAttribute('data-qid');
    var left = parseInt(card.getAttribute('data-left'), 10);
    if (!qid || Number.isNaN(left)) return;

    var from = card.getAttribute('data-from') || 'pool';
    var payload = { qid: qid, leftIdx: left, from: from };

    var piStr = card.getAttribute('data-pool-index');
    if (piStr !== null && piStr !== '') {
      var pi = parseInt(piStr, 10);
      if (!Number.isNaN(pi)) payload.poolIndex = pi;
    }

    var riStr = card.getAttribute('data-right');
    if (riStr !== null && riStr !== '') {
      var ri = parseInt(riStr, 10);
      if (!Number.isNaN(ri)) payload.rightIdx = ri;
    }

    try {
      e.dataTransfer.setData('application/json', JSON.stringify(payload));
      e.dataTransfer.setData(
        'text/plain',
        payload.qid + '|' + payload.leftIdx + '|' + payload.from + '|' +
        (payload.poolIndex !== undefined ? payload.poolIndex : '') + '|' +
        (payload.rightIdx !== undefined ? payload.rightIdx : '')
      );
      e.dataTransfer.effectAllowed = 'move';
    } catch (err) {}
  });

  // dragover
  document.addEventListener('dragover', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');

    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    dropEl.classList.add('is-over');
    try { e.dataTransfer.dropEffect = 'move'; } catch (err) {}
  });

  document.addEventListener('dragleave', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;
    dropEl.classList.remove('is-over');
  });

  // drop
  document.addEventListener('drop', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    dropEl.classList.remove('is-over');

    var payload = parsePayloadFromEvent(e);
    if (!payload || !payload.qid || Number.isNaN(payload.leftIdx)) return;

    var q = getCurrentQuestionById(payload.qid);
    if (!q || q.type !== 'matching') return;

    var ans = (state.answers[payload.qid] && typeof state.answers[payload.qid] === 'object') ? state.answers[payload.qid] : {};

    var shuffleMapping = state.shuffleMappings[q.id] || {};
    var leftMapping = shuffleMapping.left ? shuffleMapping.left : q.data.left.map(function(_, i){ return i; });

    var pool = normalizePool(payload.qid, leftMapping, ans);

    var poolSlotStr = dropEl.getAttribute('data-pool-slot');
    var targetRightStr = dropEl.getAttribute('data-right');
    var isPoolDrop = (poolSlotStr !== null && poolSlotStr !== '');

    if (isPoolDrop) {
      var targetSlot = parseInt(poolSlotStr, 10);
      if (Number.isNaN(targetSlot)) return;

      if (payload.from === 'pool') {
        var removedAt = removeFromPool(pool, payload.leftIdx, payload.poolIndex);
        if (removedAt >= 0 && removedAt < targetSlot) targetSlot = targetSlot - 1;
      } else {
        removeLeftFromAnswers(ans, payload.leftIdx);
      }

      insertIntoPool(pool, payload.leftIdx, targetSlot);

      state.answers[payload.qid] = ans;
      state.matchingPools[payload.qid] = pool;
      render();
      return;
    }

    var targetRight = parseInt(targetRightStr, 10);
    if (Number.isNaN(targetRight)) return;

    if (payload.from === 'pool') {
      removeFromPool(pool, payload.leftIdx, payload.poolIndex);
    } else {
      removeLeftFromAnswers(ans, payload.leftIdx);
    }

    var oldLeft = leftForRight(ans, targetRight);
    if (oldLeft !== null && !Number.isNaN(oldLeft)) {
      removeLeftFromAnswers(ans, oldLeft);

      if (payload.from === 'pool' && typeof payload.poolIndex === 'number') {
        insertIntoPool(pool, oldLeft, payload.poolIndex);
      } else {
        insertIntoPool(pool, oldLeft, pool.length);
      }
    }

    ans[payload.leftIdx] = targetRight;

    Object.keys(ans).forEach(function(k) {
      var li = parseInt(k, 10);
      if (li !== payload.leftIdx && ans[k] === targetRight) delete ans[k];
    });

    state.answers[payload.qid] = ans;
    state.matchingPools[payload.qid] = pool;
    render();
  });

  // dblclick matched -> return to pool
  document.addEventListener('dblclick', function(e) {
    var card = closestByClass(e.target, 'match-chip');
    if (!card) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    var from = card.getAttribute('data-from');
    if (from !== 'match') return;

    var qid = card.getAttribute('data-qid');
    var leftIdx = parseInt(card.getAttribute('data-left'), 10);
    if (!qid || Number.isNaN(leftIdx)) return;

    var q = getCurrentQuestionById(qid);
    if (!q || q.type !== 'matching') return;

    var ans = (state.answers[qid] && typeof state.answers[qid] === 'object') ? state.answers[qid] : {};
    var shuffleMapping = state.shuffleMappings[q.id] || {};
    var leftMapping = shuffleMapping.left ? shuffleMapping.left : q.data.left.map(function(_, i){ return i; });

    var pool = normalizePool(qid, leftMapping, ans);

    removeLeftFromAnswers(ans, leftIdx);
    insertIntoPool(pool, leftIdx, pool.length);

    state.answers[qid] = ans;
    state.matchingPools[qid] = pool;
    render();
  });
}
3) renderQuestionInput(q) — заменить ветку if (q.type === 'matching') { ... }
Найди старый блок (который строит .matching-grid, .matching-pool, .match-row и .match-slot) и замени полностью на это:

// MATCHING (Joined Drag & Drop like in UI)
if (q.type === 'matching') {
  var pairs = (answer && typeof answer === 'object') ? answer : {};

  var mappingObj = shuffleMapping || {};
  var leftMapping = mappingObj.left ? mappingObj.left : q.data.left.map(function(_, i){ return i; });
  var rightMapping = mappingObj.right ? mappingObj.right : q.data.right.map(function(_, i){ return i; });

  // rightIdx -> leftIdx
  var rightToLeft = {};
  Object.keys(pairs).forEach(function(k){
    var l = parseInt(k, 10);
    var r = pairs[k];
    if (typeof r === 'number') rightToLeft[r] = l;
  });

  // normalize pool
  if (!state.matchingPools) state.matchingPools = {};
  if (!Array.isArray(state.matchingPools[q.id])) state.matchingPools[q.id] = leftMapping.slice();

  var pool = state.matchingPools[q.id];

  var usedLeft = {};
  Object.keys(pairs).forEach(function(k){
    var li = parseInt(k, 10);
    if (!Number.isNaN(li)) usedLeft[li] = true;
  });

  var nextPool = [];
  for (var pi = 0; pi < pool.length; pi++) {
    if (!usedLeft[pool[pi]]) nextPool.push(pool[pi]);
  }

  leftMapping.forEach(function(li){
    if (usedLeft[li]) return;
    if (nextPool.indexOf(li) === -1) nextPool.push(li);
  });

  pool = nextPool;
  state.matchingPools[q.id] = pool;

  var html3 = '<div class="matching-board" data-qid="' + escapeHtml(q.id) + '" style="--matchRowH:auto;">';

  // pool раскладываем по НЕзаполненным строкам справа
  var poolSlot = 0;

  rightMapping.forEach(function(rightIdx) {
    var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
    var isJoined = (matchedLeft !== null);

    html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

    // LEFT
    if (isJoined) {
      html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
      html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
            + escapeHtml(q.data.left[matchedLeft])
            + '</div>';
      html3 += '</div>';
    } else {
      var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

      if (poolLeft !== null && poolLeft !== undefined) {
        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
        html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
              + escapeHtml(q.data.left[poolLeft])
              + '</div>';
        html3 += '</div>';
      } else {
        html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
              + '<span class="slot-placeholder">Перетащите вариант</span>'
              + '</div>';
      }

      poolSlot++;
    }

    html3 += '<div class="matching-gap"></div>';

    // RIGHT (drop target)
    html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
          + escapeHtml(q.data.right[rightIdx])
          + '</div>';

    html3 += '</div>';
  });

  html3 += '</div>';
  return html3;
}
4) highlightMatching() — заменить (потому что классы теперь .matching-line)
Найди старую function highlightMatching(q, answer) { ... } и замени целиком:

function highlightMatching(q, answer) {
  var pairs = (answer && typeof answer === 'object') ? answer : {};
  var correctPairsArr = Array.isArray((q.correct || {}).pairs) ? q.correct.pairs : [];

  // correct: rightIdx -> leftIdx
  var correctRightToLeft = {};
  correctPairsArr.forEach(function(p) { correctRightToLeft[p.right] = p.left; });

  // user: rightIdx -> leftIdx
  var userRightToLeft = {};
  Object.keys(pairs).forEach(function(k){
    var l = parseInt(k, 10);
    var r = pairs[k];
    if (typeof r === 'number') userRightToLeft[r] = l;
  });

  document.querySelectorAll('.matching-line[data-qid="' + q.id + '"]').forEach(function(line) {
    line.classList.remove('correct-answer', 'incorrect-answer');

    var rightAttr = line.getAttribute('data-right');
    if (rightAttr === null) return;

    var rightIdx = parseInt(rightAttr, 10);
    if (Number.isNaN(rightIdx)) return;

    if (!userRightToLeft.hasOwnProperty(rightIdx)) return;

    var userLeft = userRightToLeft[rightIdx];
    var correctLeft = correctRightToLeft[rightIdx];

    if (Number(userLeft) === Number(correctLeft)) {
      line.classList.add('correct-answer');
    } else {
      line.classList.add('incorrect-answer');
    }
  });
}
5) buildStylesCss() — заменить весь блок matching-стилей
В buildStylesCss() найди кусок начиная примерно с:

/* ===== Matching DnD ===== */
...
/* ===== Ranking Questions ===== */
и замени весь matching-блок на этот:

/* ===== Matching DnD (MATCHING) ===== */
/* Новый формат: строка = левый слот + gap + правый ответ, при совпадении "склеиваются" в одну плашку */
.matching-board{
  --matchRowH: auto;
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-top: 10px;
}

.matching-line{
  display:flex;
  align-items:stretch;
}

.matching-gap{
  flex: 0 0 18px;
}

.match-tile{
  flex: 1 1 0;
  min-width: 0;
  padding: 14px;
  border-radius: 12px;
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  box-shadow: var(--shadow);
  display:flex;
  align-items:center;
  height: var(--matchRowH);
  overflow: hidden;
  font-size: 14px;
  line-height: 1.35;
}

.match-left-slot{
  justify-content:flex-start;
  gap: 10px;
}

.match-right-tile{
  color: hsl(var(--foreground));
  opacity: .92;
  white-space: normal;
}

.match-empty{
  flex: 1 1 0;
  min-width: 0;
  padding: 14px;
  border-radius: 12px;
  background: transparent;
  border: 1px dashed hsl(var(--border));
  display:flex;
  align-items:center;
  height: var(--matchRowH);
}

.match-chip{
  user-select:none;
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  background: hsl(var(--muted) / .35);
  border: 1px solid hsl(var(--border));
  color: hsl(var(--foreground));
  cursor: grab;
  font-size: 14px;
  line-height: 1.25;
  white-space: normal;
}
.match-chip:active{ cursor: grabbing; }

/* dragover подсветка */
.match-drop-right.is-over,
.match-drop-left.is-over{
  outline: 2px solid hsl(var(--primary));
  outline-offset: 2px;
}

/* Joined state */
.matching-line.is-joined{
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  border-radius: 12px;
  box-shadow: var(--shadow);
  overflow:hidden;
}

.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;
  box-shadow: none;
  border-radius: 0;
}

.matching-line.is-joined .match-left-slot{
  border-top-left-radius: 12px;
  border-bottom-left-radius: 12px;
}

.matching-line.is-joined .match-right-tile{
  border-top-right-radius: 12px;
  border-bottom-right-radius: 12px;
}

/* Результаты */
.matching-line.correct-answer{
  border-color: hsl(var(--success));
  background: color-mix(in oklab, hsl(var(--success)) 12%, hsl(var(--card)));
}
.matching-line.incorrect-answer{
  border-color: hsl(var(--destructive));
  background: color-mix(in oklab, hsl(var(--destructive)) 10%, hsl(var(--card)));
}

.slot-placeholder{
  color: hsl(var(--muted-foreground));
  font-size: 13px;
}
Если хочешь — следующим шагом сделаю “приятность” как в твоём исходнике: показывать подсказку “Правильно: A/B/…” при неверной паре (с учётом shuffle rightMapping). Сейчас подсветка есть, но без буквенной подсказки.

Вы сказали:
Загруженное изображение
отлично надо немного доработать визуал, нам не нужен дополнительный бордер
ChatGPT сказал:
Понял. На скрине видно, что сейчас у “склеенной” строки есть лишняя рамка: мы рисуем бордер и на самой строке, и (частично) на внутренних плитках/слотах, из-за этого получается “двойной/лишний” контур.

Что делаем
Убираем бордер у контейнера строки .matching-line (в joined и вообще).

Оставляем бордер только у отдельных карточек (левый слот/правый ответ).

В состоянии is-joined делаем так, чтобы карточки выглядели “единым блоком”:
border остаётся, но внутренние углы = 0, внешние = 12px.

То есть: никакого дополнительного бордера вокруг всей строки.

✅ Замена в CSS (MATCHING блок)
В buildStylesCss() найди куски:

.match-tile{ ... border: 1px solid ... }
...
.matching-line.is-joined{
  background: ...
  border: 1px solid ...
  border-radius: 12px;
  ...
}
.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;
  ...
}
и замени joined-часть на это:

/* Joined state — БЕЗ внешнего бордера у строки */
.matching-line.is-joined{
  background: transparent;
  border: 0;
  border-radius: 0;
  box-shadow: none;
}

/* В joined оставляем карточки как есть, но "склеиваем" их углами */
.matching-line.is-joined .match-left-slot{
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.matching-line.is-joined .match-right-tile{
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

/* gap можно чуть уменьшить для ощущения склейки (опционально) */
/* .matching-gap{ flex: 0 0 12px; } */
⚠️ И удали/не используй этот блок (он и даёт лишний контур):

.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;
  box-shadow: none;
  border-radius: 0;
}
Итог по визуалу
каждая половина (слева и справа) остаётся “карточкой” с твоим бордером,

но в joined они выглядят как единая (внутренние радиусы = 0),

без дополнительной рамки вокруг строки.

Если хочешь ещё ближе к скрину: можно убрать border у левой маленькой плашки (match-chip) или сделать его менее контрастным — скажи, и я дам точные строки CSS под твою палитру.

Вы сказали:
/* ===== Matching DnD (MATCHING) ===== */
/* Новый формат: строка = левый слот + gap + правый ответ, при совпадении "склеиваются" в одну плашку */
.matching-board{
  --matchRowH: auto;
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-top: 10px;
}

.matching-line{
  display:flex;
  align-items:stretch;
}

.matching-gap{
  flex: 0 0 18px;
}

.match-tile{
  flex: 1 1 0;
  min-width: 0;
  padding: 14px;
  border-radius: 12px;
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  box-shadow: var(--shadow);
  display:flex;
  align-items:center;
  height: var(--matchRowH);
  overflow: hidden;
  font-size: 14px;
  line-height: 1.35;
}

.match-left-slot{
  justify-content:flex-start;
  gap: 10px;
}

.match-right-tile{
  color: hsl(var(--foreground));
  opacity: .92;
  white-space: normal;
}

.match-empty{
  flex: 1 1 0;
  min-width: 0;
  padding: 14px;
  border-radius: 12px;
  background: transparent;
  border: 1px dashed hsl(var(--border));
  display:flex;
  align-items:center;
  height: var(--matchRowH);
}

.match-chip{
  user-select:none;
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  background: hsl(var(--muted) / .35);
  border: 1px solid hsl(var(--border));
  color: hsl(var(--foreground));
  cursor: grab;
  font-size: 14px;
  line-height: 1.25;
  white-space: normal;
}
.match-chip:active{ cursor: grabbing; }

/* dragover подсветка */
.match-drop-right.is-over,
.match-drop-left.is-over{
  outline: 2px solid hsl(var(--primary));
  outline-offset: 2px;
}

/* Joined state */
.matching-line.is-joined{
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  border-radius: 12px;
  box-shadow: var(--shadow);
  overflow:hidden;
}

.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;
  box-shadow: none;
  border-radius: 0;
}

.matching-line.is-joined .match-left-slot{
  border-top-left-radius: 12px;
  border-bottom-left-radius: 12px;
}

.matching-line.is-joined .match-right-tile{
  border-top-right-radius: 12px;
  border-bottom-right-radius: 12px;
}

/* Результаты */
.matching-line.correct-answer{
  border-color: hsl(var(--success));
  background: color-mix(in oklab, hsl(var(--success)) 12%, hsl(var(--card)));
}
.matching-line.incorrect-answer{
  border-color: hsl(var(--destructive));
  background: color-mix(in oklab, hsl(var(--destructive)) 10%, hsl(var(--card)));
}

.slot-placeholder{
  color: hsl(var(--muted-foreground));
  font-size: 13px;
}
ChatGPT сказал:
Да, вот здесь как раз “лишний бордер” создаёт этот блок:

.matching-line.is-joined{
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));   /* <-- лишний */
  border-radius: 12px;
  box-shadow: var(--shadow);
  overflow:hidden;
}

.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;                              /* <-- и из-за этого рамка остаётся только у контейнера */
  ...
}
Тебе нужно наоборот: без рамки у контейнера строки, и рамка должна оставаться у двух карточек (left/right), просто “склеиваем” радиусы.

✅ Вставь вместо всего /* Joined state */ вот это
/* Joined state — без внешнего бордера у строки */
.matching-line.is-joined{
  background: transparent;
  border: 0;
  border-radius: 0;
  box-shadow: none;
  overflow: visible;
}

/* В joined карточки остаются карточками (своими border/shadow), только склеиваем углы */
.matching-line.is-joined .match-left-slot{
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.matching-line.is-joined .match-right-tile{
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

/* Внутренние плитки НЕ обнуляем! (удали старый блок ниже)
   .matching-line.is-joined .match-tile,
   .matching-line.is-joined .match-empty { ... }
*/
И УДАЛИ полностью этот кусок (он больше не нужен)
.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;
  box-shadow: none;
  border-radius: 0;
}
✅ Плюс: чтобы “склейка” выглядела плотнее (опционально)
Если хочешь, чтобы визуально было прям как “единая плашка”, можно уменьшить gap только в joined:

.matching-line.is-joined .matching-gap{
  flex-basis: 0px;
}
Но если тебе важен именно отступ как сейчас — не добавляй.

Про “Результаты” (correct/incorrect)
Сейчас классы correct-answer/incorrect-answer навешиваются на .matching-line. После снятия бордера со строки, эти стили будут не видны (они меняют border-color/background строки).

Если надо, чтобы подсветка оставалась, лучше перенести её на плитки:

.matching-line.correct-answer .match-left-slot,
.matching-line.correct-answer .match-right-tile{
  border-color: hsl(var(--success));
}

.matching-line.incorrect-answer .match-left-slot,
.matching-line.incorrect-answer .match-right-tile{
  border-color: hsl(var(--destructive));
}
(И можно чуть подсветить фон плиток через background: color-mix(...).)

Хочешь, чтобы подсветка работала как сейчас, но без внешнего бордера — скажи, сделаю финальный блок “correct/incorrect” под твою палитру аккуратно.

Вы сказали:
перепиши весь стиль блока целиком и пришли
ChatGPT сказал:
/* ===== Matching DnD (MATCHING) ===== */
/* Формат: строка = левый слот + gap + правый ответ.
   При совпадении визуально "склеиваем" ТОЛЬКО углами, без внешнего бордера у строки. */
.matching-board{
  --matchRowH: auto;
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 10px;
}

.matching-line{
  display: flex;
  align-items: stretch;
}

.matching-gap{
  flex: 0 0 18px;
}

/* базовая карточка (и слева, и справа) */
.match-tile{
  flex: 1 1 0;
  min-width: 0;

  padding: 14px;
  border-radius: 12px;

  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  box-shadow: var(--shadow);

  display: flex;
  align-items: center;

  height: var(--matchRowH);
  overflow: hidden;

  font-size: 14px;
  line-height: 1.35;
}

.match-left-slot{
  justify-content: flex-start;
  gap: 10px;
}

.match-right-tile{
  color: hsl(var(--foreground));
  opacity: .92;
  white-space: normal;
}

/* пустой слот слева */
.match-empty{
  flex: 1 1 0;
  min-width: 0;

  padding: 14px;
  border-radius: 12px;

  background: transparent;
  border: 1px dashed hsl(var(--border));

  display: flex;
  align-items: center;

  height: var(--matchRowH);
}

/* draggable "плашка" факта */
.match-chip{
  user-select: none;
  width: 100%;

  padding: 10px 12px;
  border-radius: 12px;

  background: hsl(var(--muted) / .35);
  border: 1px solid hsl(var(--border));
  color: hsl(var(--foreground));

  cursor: grab;
  font-size: 14px;
  line-height: 1.25;

  white-space: normal;
}
.match-chip:active{ cursor: grabbing; }

/* dragover подсветка */
.match-drop-right.is-over,
.match-drop-left.is-over{
  outline: 2px solid hsl(var(--primary));
  outline-offset: 2px;
}

/* ===== Joined state (без внешнего бордера у строки) ===== */
.matching-line.is-joined{
  background: transparent;
  border: 0;
  border-radius: 0;
  box-shadow: none;
  overflow: visible;
}

/* В joined оставляем бордер/фон на плитках, просто "склеиваем" их углы */
.matching-line.is-joined .match-left-slot{
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}

.matching-line.is-joined .match-right-tile{
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

/* (опционально) Если хочешь прям вплотную склеить — раскомментируй */
/*
.matching-line.is-joined .matching-gap{
  flex-basis: 0px;
}
*/

/* ===== Результаты (подсветка без внешнего бордера) ===== */
.matching-line.correct-answer .match-left-slot,
.matching-line.correct-answer .match-right-tile{
  border-color: hsl(var(--success));
}

.matching-line.incorrect-answer .match-left-slot,
.matching-line.incorrect-answer .match-right-tile{
  border-color: hsl(var(--destructive));
}

/* лёгкая заливка (по желанию) */
.matching-line.correct-answer .match-left-slot,
.matching-line.correct-answer .match-right-tile{
  background: color-mix(in oklab, hsl(var(--success)) 10%, hsl(var(--card)));
}

.matching-line.incorrect-answer .match-left-slot,
.matching-line.incorrect-answer .match-right-tile{
  background: color-mix(in oklab, hsl(var(--destructive)) 8%, hsl(var(--card)));
}

.slot-placeholder{
  color: hsl(var(--muted-foreground));
  font-size: 13px;
}
Вы сказали:
/* ===== Matching DnD (MATCHING) ===== */
/* Новый формат: строка = левый слот + gap + правый ответ, при совпадении "склеиваются" в одну плашку */
.matching-board{
  --matchRowH: auto;
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-top: 10px;
}

.matching-line{
  display:flex;
  align-items:stretch;
}

.matching-gap{
  flex: 0 0 18px;
}

.match-tile{
  flex: 1 1 0;
  min-width: 0;
  padding: 14px;
  border-radius: 12px;
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  box-shadow: var(--shadow);
  display:flex;
  align-items:center;
  height: var(--matchRowH);
  overflow: hidden;
  font-size: 14px;
  line-height: 1.35;
}

.match-left-slot{
  justify-content:flex-start;
  gap: 10px;
}

.match-right-tile{
  color: hsl(var(--foreground));
  opacity: .92;
  white-space: normal;
}

.match-empty{
  flex: 1 1 0;
  min-width: 0;
  padding: 14px;
  border-radius: 12px;
  background: transparent;
  border: 1px dashed hsl(var(--border));
  display:flex;
  align-items:center;
  height: var(--matchRowH);
}

.match-chip{
  user-select:none;
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  background: hsl(var(--muted) / .35);
  border: 1px solid hsl(var(--border));
  color: hsl(var(--foreground));
  cursor: grab;
  font-size: 14px;
  line-height: 1.25;
  white-space: normal;
}
.match-chip:active{ cursor: grabbing; }

/* dragover подсветка */
.match-drop-right.is-over,
.match-drop-left.is-over{
  outline: 2px solid hsl(var(--primary));
  outline-offset: 2px;
}

/* Joined state */
.matching-line.is-joined{
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  border-radius: 12px;
  box-shadow: var(--shadow);
  overflow:hidden;
}

.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  background: transparent;
  border: 0;
  box-shadow: none;
  border-radius: 0;
}

.matching-line.is-joined .match-left-slot{
  border-top-left-radius: 12px;
  border-bottom-left-radius: 12px;
}

.matching-line.is-joined .match-right-tile{
  border-top-right-radius: 12px;
  border-bottom-right-radius: 12px;
}

/* Результаты */
.matching-line.correct-answer{
  border-color: hsl(var(--success));
  background: color-mix(in oklab, hsl(var(--success)) 12%, hsl(var(--card)));
}
.matching-line.incorrect-answer{
  border-color: hsl(var(--destructive));
  background: color-mix(in oklab, hsl(var(--destructive)) 10%, hsl(var(--card)));
}

.slot-placeholder{
  color: hsl(var(--muted-foreground));
  font-size: 13px;
}


Вот что сейчас у меня есть

покажи где именно у меня рисуется бордер для левой стороны каждой картички?
ChatGPT сказал:
У тебя “бордер левой стороны” появляется из двух мест — в зависимости от состояния строки.

1) Обычное состояние (не joined)
Бордер у левой карточки рисуется вот здесь:

.match-tile{
  ...
  border: 1px solid hsl(var(--border));  /* ← это рамка со всех 4 сторон, включая левую */
}
То есть левая грань = часть этого border.

Если слева пусто (пунктир), тогда бордер слева рисуется тут:

.match-empty{
  ...
  border: 1px dashed hsl(var(--border)); /* ← пунктир со всех сторон, включая левую */
}
2) Joined state (когда “склеено”)
Ты обнуляешь бордер у внутренних плиток:

.matching-line.is-joined .match-tile,
.matching-line.is-joined .match-empty{
  border: 0;  /* ← тут бордер у левой карточки УБИРАЕТСЯ полностью */
}
И дальше бордер слева у “склеенной строки” рисуется уже не у левой карточки, а у контейнера строки:

.matching-line.is-joined{
  border: 1px solid hsl(var(--border));  /* ← вот это и есть бордер слева для joined */
}
Именно поэтому ты видишь “лишний внешний бордер” — он рисуется на всей строке, а не на половинках.

Если ты хочешь, чтобы бордер всегда принадлежал именно карточкам, то в joined нужно:

убрать border у .matching-line.is-joined

убрать border:0 у .match-tile/.match-empty внутри joined

и склеивать только радиусами.

Вы сказали:
    /* background: hsl(var(--muted) / .35); */
    /* border: 1px solid hsl(var(--border));


Вот что надо отключать
ChatGPT сказал:
Да — если ты хочешь убрать рамку у самой “плашки факта” внутри левой карточки (то есть у .match-chip), то отключать нужно именно это:

.match-chip{
  /* background: hsl(var(--muted) / .35); */
  /* border: 1px solid hsl(var(--border)); */
}
Чтобы выглядело аккуратно (без “второй рамки”), лучше не просто закомментировать, а задать нейтрально:

.match-chip{
  background: transparent;
  border: 0;
  padding: 0;          /* опционально: чтобы текст сел как обычный текст */
}
Если хочешь сохранить “таблетку” (фон), но без рамки — так:

.match-chip{
  background: hsl(var(--muted) / .35);
  border: 0;
}
⚠️ Рамка левой карточки при этом останется, потому что она задаётся не в .match-chip, а в .match-tile { border: 1px solid ... }.

Если скажешь какой вариант визуально нужен:

вообще без плашки (только текст),

с фоном, но без рамки,

с фоном и с рамкой,
— я подгоню точные значения padding/line-height под твой макет.

Вы сказали:
Загруженное изображение
не хватает правильного расположения
ChatGPT сказал:

Думал на протяжении 1m 18s
Понял: сейчас после проверки ты подсвечиваешь правильно/неправильно, но не показываешь “как правильно должно быть расположено” (в скрине остаётся пользовательская расстановка, просто две строки красные).

Сделаем так:

В режиме фидбэка (state.feedbackShown && TEST_DATA.showCorrectAnswers) рендерим слева правильные варианты (то есть “правильное расположение”).

При этом подсветка красное/зелёное останется по пользовательскому ответу (как сейчас).

Для красных строк добавим мелкую подпись “Ваш ответ: …”, чтобы было понятно, что было выбрано.

Ниже — точечные правки.

1) CSS: добавь стили для подписи “Ваш ответ”
Внутри твоего блока /* ===== Matching DnD (MATCHING) ===== */ добавь в конец:

.match-left-stack{
  display: flex;
  flex-direction: column;
  gap: 6px;
  width: 100%;
  min-width: 0;
}

.match-wrong-hint{
  font-size: 12px;
  line-height: 1.2;
  color: hsl(var(--muted-foreground));
  opacity: .9;
}
Ничего из текущих стилей менять не надо — это только для новой подписи.

2) JS: правим рендер MATCHING, чтобы в фидбэке показывать правильное расположение
Найди в renderQuestionInput(q) твой блок:

if (q.type === 'matching') {
  var pairs = (answer && typeof answer === 'object') ? answer : {};
  ...
}
и вставь/замени внутри него следующие части.

2.1) Сразу после var pairs = ... добавь вычисление correct-пар
var pairs = (answer && typeof answer === 'object') ? answer : {};

var correctPairsArr = Array.isArray((q.correct || {}).pairs) ? q.correct.pairs : [];
var correctRightToLeft = {};
var correctLeftToRight = {};
correctPairsArr.forEach(function(p){
  correctRightToLeft[p.right] = p.left;
  correctLeftToRight[p.left] = p.right;
});

// в фидбэке хотим показывать корректное расположение
var showCorrectLayout = !!(TEST_DATA.showCorrectAnswers && state.feedbackShown);

// но подсветку считаем по user-ответу (pairs)
var userPairs = pairs;

// а рендерим либо userPairs, либо правильные
var pairsForRender = showCorrectLayout ? correctLeftToRight : userPairs;
2.2) Там, где ты строишь rightToLeft, замени на:
// rightIdx -> leftIdx (то, что будет отображаться слева)
var rightToLeft = {};
Object.keys(pairsForRender).forEach(function(k){
  var l = parseInt(k, 10);
  var r = pairsForRender[k];
  if (typeof r === 'number') rightToLeft[r] = l;
});
2.3) Там, где ты нормализуешь pool/usedLeft — используй pairsForRender, а НЕ pairs
Вот этот кусок:

var usedLeft = {};
Object.keys(pairs).forEach(function(k){
  ...
});
замени на:

var usedLeft = {};
Object.keys(pairsForRender).forEach(function(k){
  var li = parseInt(k, 10);
  if (!Number.isNaN(li)) usedLeft[li] = true;
});
(И ниже, где ты ещё используешь pairs для пула — тоже замени на pairsForRender.)

2.4) Внутри цикла rightMapping.forEach(...) добавь подпись “Ваш ответ”, если строка была неверная
Сейчас у тебя примерно так:

var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
var isJoined = (matchedLeft !== null);

if (isJoined) {
  html3 += '<div class="match-tile ...">';
  html3 +=   '<div class="match-chip" ...>' + leftText + '</div>';
  html3 += '</div>';
} else { ... }
ЗАМЕНИ joined-часть на такую (важно: добавили .match-left-stack и hint):

var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
var isJoined = (matchedLeft !== null && matchedLeft !== undefined);

if (isJoined) {
  // "Ваш ответ" берём из userPairs (даже если показываем правильный layout)
  var userLeftForThisRight = null;
  (function(){
    // user: right -> left
    var userRightToLeft = {};
    Object.keys(userPairs).forEach(function(k){
      var l = parseInt(k, 10);
      var r = userPairs[k];
      if (typeof r === 'number') userRightToLeft[r] = l;
    });
    if (userRightToLeft.hasOwnProperty(rightIdx)) userLeftForThisRight = userRightToLeft[rightIdx];
  })();

  var hintHtml = '';
  if (showCorrectLayout && userLeftForThisRight !== null && userLeftForThisRight !== undefined) {
    // если пользователь ошибся — покажем подсказку
    var correctLeft = correctRightToLeft[rightIdx];
    if (typeof correctLeft === 'number' && typeof userLeftForThisRight === 'number' && correctLeft !== userLeftForThisRight) {
      hintHtml = '<div class="match-wrong-hint">Ваш ответ: ' + escapeHtml(q.data.left[userLeftForThisRight]) + '</div>';
    }
  }

  html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
  html3 +=   '<div class="match-left-stack">';
  html3 +=     '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
        +       escapeHtml(q.data.left[matchedLeft])
        +     '</div>';
  html3 +=     hintHtml;
  html3 +=   '</div>';
  html3 += '</div>';
} else {
  ...
}
Важно: если showCorrectLayout = true, то matchedLeft будет правильным, а Ваш ответ: покажет то, что выбрал пользователь (если ошибся).

Почему это решит “не хватает правильного расположения”
В режиме фидбэка ты увидишь правильную расстановку слева (то, что должно быть).

При этом красная подсветка останется там, где пользователь ошибся.

И будет ясно “что ты поставил” через подпись.

Если хочешь — могу сделать ещё лучше: для неправильных строк показывать две плашки (правильная + пользовательская зачёркнутая), но это уже чуть больше по UI.

Вы сказали:
rightMapping.forEach(function(rightIdx) {
      var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
      var isJoined = (matchedLeft !== null);

      html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

      // LEFT
      if (isJoined) {
        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
        html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
              + escapeHtml(q.data.left[matchedLeft])
              + '</div>';
        html3 += '</div>';
      } else {
        var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

        if (poolLeft !== null && poolLeft !== undefined) {
          html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
          html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
                + escapeHtml(q.data.left[poolLeft])
                + '</div>';
          html3 += '</div>';
        } else {
          html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
                + '<span class="slot-placeholder">Перетащите вариант</span>'
                + '</div>';
        }

        poolSlot++;
      }

      html3 += '<div class="matching-gap"></div>';

      // RIGHT (drop target)
      html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
            + escapeHtml(q.data.right[rightIdx])
            + '</div>';

      html3 += '</div>';
    });
ChatGPT сказал:
Ок — вот точечная замена именно этого rightMapping.forEach(...), чтобы в режиме фидбэка показывалось правильное расположение, а для ошибочных строк — подпись «Ваш ответ: …».

✅ 1) ПЕРЕД этим циклом (один раз) добавь вычисление userRightToLeft
// user: right -> left (то, что выбрал пользователь)
var userRightToLeft = {};
Object.keys(userPairs || {}).forEach(function(k){
  var l = parseInt(k, 10);
  var r = userPairs[k];
  if (typeof r === 'number') userRightToLeft[r] = l;
});
userPairs — это твой реальный ответ пользователя (то, что сейчас в answer/pairs), даже если ты в фидбэке рендеришь правильную раскладку.

✅ 2) ЗАМЕНИ ВЕСЬ твой rightMapping.forEach(function(rightIdx) { ... }); на это
rightMapping.forEach(function(rightIdx) {
  var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
  var isJoined = (matchedLeft !== null && matchedLeft !== undefined);

  html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

  // LEFT
  if (isJoined) {
    // В фидбэке: показываем правильный matchedLeft (он уже в rightToLeft),
    // но дополнительно показываем "Ваш ответ", если он отличается
    var hintHtml = '';
    if (showCorrectLayout) {
      var userLeftForThisRight = userRightToLeft.hasOwnProperty(rightIdx) ? userRightToLeft[rightIdx] : null;
      var correctLeftForThisRight = correctRightToLeft.hasOwnProperty(rightIdx) ? correctRightToLeft[rightIdx] : null;

      if (userLeftForThisRight !== null && correctLeftForThisRight !== null && userLeftForThisRight !== correctLeftForThisRight) {
        hintHtml = '<div class="match-wrong-hint">Ваш ответ: ' + escapeHtml(q.data.left[userLeftForThisRight]) + '</div>';
      }
    }

    html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
    html3 +=   '<div class="match-left-stack">';
    html3 +=     '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
          +       escapeHtml(q.data.left[matchedLeft])
          +     '</div>';
    html3 +=     hintHtml;
    html3 +=   '</div>';
    html3 += '</div>';
  } else {
    var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

    if (poolLeft !== null && poolLeft !== undefined) {
      html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
      html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
            +     escapeHtml(q.data.left[poolLeft])
            +   '</div>';
      html3 += '</div>';
    } else {
      html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
            +   '<span class="slot-placeholder">Перетащите вариант</span>'
            + '</div>';
    }

    poolSlot++;
  }

  html3 += '<div class="matching-gap"></div>';

  // RIGHT (drop target)
  html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
        +   escapeHtml(q.data.right[rightIdx])
        + '</div>';

  html3 += '</div>';
});
✅ 3) Не забудь CSS для этих двух классов
(если ещё не добавлял)

.match-left-stack{
  display:flex;
  flex-direction:column;
  gap: 6px;
  width: 100%;
  min-width: 0;
}

.match-wrong-hint{
  font-size: 12px;
  line-height: 1.2;
  color: hsl(var(--muted-foreground));
  opacity: .9;
}
Если хочешь — могу сделать ещё лучше: в ошибочных строках показывать две плашки (“Правильно: …” и “Ваш ответ: …”) или “Ваш ответ” серым/зачёркнутым.

Вы сказали:
Загруженное изображение
Я все сделал как ты предложил но не показывается как правильно
ChatGPT сказал:

Думал на протяжении 1m 58s
По скрину видно важное: подсветка (зелёный/красный) работает, но слева остаётся пользовательский вариант (например, “WIFI” рядом с описанием ADSL).
Это означает только одно: в рендере MATCHING у тебя showCorrectLayout = false, поэтому rightToLeft строится из userPairs, а не из correct.

Самый надёжный способ — не изобретать новый флаг, а использовать уже готовый locked, который у тебя в renderQuestionInput есть:

var locked = TEST_DATA.showCorrectAnswers && state.feedbackShown;
✅ Что именно поправить (минимально и точно)
1) Внутри if (q.type === 'matching') { ... } в самом начале замени старт на такой блок
ВАЖНО: это вставляется до построения rightToLeft и до нормализации pool.

var userPairs = (answer && typeof answer === 'object') ? answer : {};

// правильные пары (с фоллбеками)
var correctPairsArr =
  Array.isArray((q.correct || {}).pairs) ? q.correct.pairs :
  Array.isArray((q.correct || {}).correctPairs) ? q.correct.correctPairs :
  [];

var correctRightToLeft = {};
var correctLeftToRight = {};
correctPairsArr.forEach(function(p){
  correctRightToLeft[p.right] = p.left;
  correctLeftToRight[p.left] = p.right;
});

// 🔥 вот ключ: показывать правильное расположение когда locked
var showCorrectLayout = locked;

// что именно рендерим слева
var pairsForRender = showCorrectLayout ? correctLeftToRight : userPairs;
2) В твоём коде, где строишь rightToLeft, замени pairs на pairsForRender
Было:

Object.keys(pairs).forEach(function(k){
Должно быть:

Object.keys(pairsForRender).forEach(function(k){
И аналогично ниже, где считаешь usedLeft — тоже по pairsForRender, иначе пул “сломается” в режиме правильного отображения.

Почему именно так
locked у тебя точно становится true после нажатия “Принять” (потому что state.feedbackShown = true), и он уже завязан на настройку теста showCorrectAnswers.

если ты вычислял showCorrectLayout через другой флаг/условие и ошибся — он оставался false, и рендер всегда показывал пользовательскую расстановку.

Быстрая проверка (чтобы без догадок)
На время добавь в начало matching-рендера:

console.log('locked=', locked, 'feedbackShown=', state.feedbackShown, 'showCorrect=', TEST_DATA.showCorrectAnswers);
После “Принять” должно быть: locked=true.

Если хочешь, я следующим сообщением дам готовый цельный блок if (q.type === 'matching') { ... } целиком уже с правильным расположением + “Ваш ответ: …” для ошибок, чтобы ты просто заменил один кусок.

Вы сказали:
// MATCHING (Joined Drag & Drop like in UI)
  if (q.type === 'matching') {
    var pairs = (answer && typeof answer === 'object') ? answer : {};

    var correctPairsArr = Array.isArray((q.correct || {}).pairs) ? q.correct.pairs : [];
    var correctRightToLeft = {};
    var correctLeftToRight = {};
    correctPairsArr.forEach(function(p){
      correctRightToLeft[p.right] = p.left;
      correctLeftToRight[p.left] = p.right;
    });

    // в фидбэке хотим показывать корректное расположение
    var showCorrectLayout = !!(TEST_DATA.showCorrectAnswers && state.feedbackShown);

    // но подсветку считаем по user-ответу (pairs)
    var userPairs = pairs;

    // а рендерим либо userPairs, либо правильные
    var pairsForRender = showCorrectLayout ? correctLeftToRight : userPairs;

    var mappingObj = shuffleMapping || {};
    var leftMapping = mappingObj.left ? mappingObj.left : q.data.left.map(function(_, i){ return i; });
    var rightMapping = mappingObj.right ? mappingObj.right : q.data.right.map(function(_, i){ return i; });

    // rightIdx -> leftIdx (то, что будет отображаться слева)
    var rightToLeft = {};
    Object.keys(pairsForRender).forEach(function(k){
      var l = parseInt(k, 10);
      var r = pairsForRender[k];
      if (typeof r === 'number') rightToLeft[r] = l;
    });


    // normalize pool
    if (!state.matchingPools) state.matchingPools = {};
    if (!Array.isArray(state.matchingPools[q.id])) state.matchingPools[q.id] = leftMapping.slice();

    var pool = state.matchingPools[q.id];

    var usedLeft = {};
    Object.keys(pairsForRender).forEach(function(k){
      var li = parseInt(k, 10);
      if (!Number.isNaN(li)) usedLeft[li] = true;
    });


    var nextPool = [];
    for (var pi = 0; pi < pool.length; pi++) {
      if (!usedLeft[pool[pi]]) nextPool.push(pool[pi]);
    }

    leftMapping.forEach(function(li){
      if (usedLeft[li]) return;
      if (nextPool.indexOf(li) === -1) nextPool.push(li);
    });

    pool = nextPool;
    state.matchingPools[q.id] = pool;

    var html3 = '<div class="matching-board" data-qid="' + escapeHtml(q.id) + '" style="--matchRowH:auto;">';

    // pool раскладываем по НЕзаполненным строкам справа
    var poolSlot = 0;

    rightMapping.forEach(function(rightIdx) {
      var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
      var isJoined = (matchedLeft !== null && matchedLeft !== undefined);

      html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

      // LEFT
      if (isJoined) {
        // В фидбэке: показываем правильный matchedLeft (он уже в rightToLeft),
        // но дополнительно показываем "Ваш ответ", если он отличается
        var hintHtml = '';
        if (showCorrectLayout) {
          var userLeftForThisRight = userRightToLeft.hasOwnProperty(rightIdx) ? userRightToLeft[rightIdx] : null;
          var correctLeftForThisRight = correctRightToLeft.hasOwnProperty(rightIdx) ? correctRightToLeft[rightIdx] : null;

          if (userLeftForThisRight !== null && correctLeftForThisRight !== null && userLeftForThisRight !== correctLeftForThisRight) {
            hintHtml = '<div class="match-wrong-hint">Ваш ответ: ' + escapeHtml(q.data.left[userLeftForThisRight]) + '</div>';
          }
        }

        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
        html3 +=   '<div class="match-left-stack">';
        html3 +=     '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
              +       escapeHtml(q.data.left[matchedLeft])
              +     '</div>';
        html3 +=     hintHtml;
        html3 +=   '</div>';
        html3 += '</div>';
      } else {
        var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

        if (poolLeft !== null && poolLeft !== undefined) {
          html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
          html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
                +     escapeHtml(q.data.left[poolLeft])
                +   '</div>';
          html3 += '</div>';
        } else {
          html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
                +   '<span class="slot-placeholder">Перетащите вариант</span>'
                + '</div>';
        }

        poolSlot++;
      }

      html3 += '<div class="matching-gap"></div>';

      // RIGHT (drop target)
      html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
            +   escapeHtml(q.data.right[rightIdx])
            + '</div>';

      html3 += '</div>';
    });

    html3 += '</div>';
    return html3;
  }
ChatGPT сказал:

Думал на протяжении 40s
В твоём куске логика почти правильная, но есть 2 причины, почему “как правильно” не появляется:

1) userRightToLeft у тебя НЕ объявлен
Внутри forEach ты используешь userRightToLeft..., но его нет в показанном фрагменте.
Из-за этого JS падает в рантайме (в консоли будет ReferenceError: userRightToLeft is not defined), и дальше ты видишь “как было” (или вообще частичный рендер в зависимости от того, как у тебя обёрнут рендер).

2) correctPairsArr может быть пустой (и тогда показывать “правильно” просто нечем)
Ты берёшь только q.correct.pairs. В твоём проекте правильные пары иногда лежат в другом поле.

✅ Исправление (точечно)
A) Добавь перед rightMapping.forEach(...) вычисление userRightToLeft
Вставь вот этот блок прямо перед циклом rightMapping.forEach:

// user: right -> left (то, что выбрал пользователь)
var userRightToLeft = {};
Object.keys(userPairs || {}).forEach(function(k){
  var l = parseInt(k, 10);
  var r = userPairs[k];
  if (typeof r === 'number') userRightToLeft[r] = l;
});
B) Сделай извлечение correct-пар с фоллбеками
Замени свою строку:

var correctPairsArr = Array.isArray((q.correct || {}).pairs) ? q.correct.pairs : [];
на это:

var correctPairsArr =
  Array.isArray((q.correct || {}).pairs) ? q.correct.pairs :
  Array.isArray(q.correctPairs) ? q.correctPairs :
  Array.isArray((q.data || {}).pairs) ? q.data.pairs :
  Array.isArray((q.data || {}).correctPairs) ? q.data.correctPairs :
  [];
Это важно: иначе correctLeftToRight будет пустым, и “правильная раскладка” не сможет отрисоваться.

🔍 Быстрая проверка (чтобы сразу увидеть, что включилось)
Внутри matching-блока (после showCorrectLayout) временно добавь:

console.log('showCorrectLayout=', showCorrectLayout, 'correctPairsArrLen=', correctPairsArr.length);
После нажатия “Принять” должно быть:

showCorrectLayout = true

correctPairsArrLen > 0

На заметку
Твой showCorrectLayout сейчас ок:

var showCorrectLayout = !!(TEST_DATA.showCorrectAnswers && state.feedbackShown);
Если вдруг он остаётся false, значит state.feedbackShown реально не становится true в момент рендера (но по твоему скрину подсветка уже есть, так что скорее всего проблема именно в userRightToLeft + пустом correctPairsArr).

Если хочешь — кинь, пожалуйста, один console.log(q.correct, q.data) для matching-вопроса, и я скажу, точно в каком поле у тебя лежат правильные пары, чтобы не держать 4 фоллбека.

Вы сказали:
выведи полностью готовый код
ChatGPT сказал:
// MATCHING (Joined Drag & Drop like in UI)
if (q.type === 'matching') {
  // user answer (leftIdx -> rightIdx)
  var userPairs = (answer && typeof answer === 'object') ? answer : {};

  // correct pairs (try several fallbacks because projects store it differently)
  var correctPairsArr =
    Array.isArray((q.correct || {}).pairs) ? q.correct.pairs :
    Array.isArray((q.correct || {}).correctPairs) ? q.correct.correctPairs :
    Array.isArray(q.correctPairs) ? q.correctPairs :
    Array.isArray((q.data || {}).pairs) ? q.data.pairs :
    Array.isArray((q.data || {}).correctPairs) ? q.data.correctPairs :
    [];

  // correct maps
  var correctRightToLeft = {}; // right -> left
  var correctLeftToRight = {}; // left -> right
  correctPairsArr.forEach(function(p){
    if (!p) return;
    correctRightToLeft[p.right] = p.left;
    correctLeftToRight[p.left] = p.right;
  });

  // show correct layout only in feedback mode
  // NOTE: if you already have `locked` above in renderQuestionInput, prefer:
  // var showCorrectLayout = locked;
  var showCorrectLayout = !!(TEST_DATA.showCorrectAnswers && state.feedbackShown);

  // what to render on the left side:
  // - in normal mode: user's pairs
  // - in feedback: correct layout
  var pairsForRender = showCorrectLayout ? correctLeftToRight : userPairs;

  var mappingObj = shuffleMapping || {};
  var leftMapping = mappingObj.left ? mappingObj.left : q.data.left.map(function(_, i){ return i; });
  var rightMapping = mappingObj.right ? mappingObj.right : q.data.right.map(function(_, i){ return i; });

  // rightIdx -> leftIdx (VISIBLE LEFT item for each right)
  var rightToLeft = {};
  Object.keys(pairsForRender).forEach(function(k){
    var l = parseInt(k, 10);
    var r = pairsForRender[k];
    if (typeof r === 'number') rightToLeft[r] = l;
  });

  // user: rightIdx -> leftIdx (for "Ваш ответ" hint in feedback)
  var userRightToLeft = {};
  Object.keys(userPairs).forEach(function(k){
    var l2 = parseInt(k, 10);
    var r2 = userPairs[k];
    if (typeof r2 === 'number') userRightToLeft[r2] = l2;
  });

  // --- normalize pool (unmatched left options shown on empty rows) ---
  if (!state.matchingPools) state.matchingPools = {};
  if (!Array.isArray(state.matchingPools[q.id])) state.matchingPools[q.id] = leftMapping.slice();

  var pool = state.matchingPools[q.id];

  // left indices that are already used (based on what we RENDER now)
  var usedLeft = {};
  Object.keys(pairsForRender).forEach(function(k){
    var li = parseInt(k, 10);
    if (!Number.isNaN(li)) usedLeft[li] = true;
  });

  // remove used from pool
  var nextPool = [];
  for (var pi = 0; pi < pool.length; pi++) {
    if (!usedLeft[pool[pi]]) nextPool.push(pool[pi]);
  }

  // add missing unused in leftMapping order
  leftMapping.forEach(function(li){
    if (usedLeft[li]) return;
    if (nextPool.indexOf(li) === -1) nextPool.push(li);
  });

  pool = nextPool;
  state.matchingPools[q.id] = pool;

  // --- render ---
  var html3 = '<div class="matching-board" data-qid="' + escapeHtml(q.id) + '" style="--matchRowH:auto;">';

  // pool is laid out only for NOT-joined rows
  var poolSlot = 0;

  rightMapping.forEach(function(rightIdx) {
    var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
    var isJoined = (matchedLeft !== null && matchedLeft !== undefined);

    html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

    // LEFT
    if (isJoined) {
      // feedback hint: show user's choice if differs from correct
      var hintHtml = '';
      if (showCorrectLayout) {
        var userLeftForThisRight = userRightToLeft.hasOwnProperty(rightIdx) ? userRightToLeft[rightIdx] : null;
        var correctLeftForThisRight = correctRightToLeft.hasOwnProperty(rightIdx) ? correctRightToLeft[rightIdx] : null;

        if (userLeftForThisRight !== null && correctLeftForThisRight !== null && userLeftForThisRight !== correctLeftForThisRight) {
          hintHtml = '<div class="match-wrong-hint">Ваш ответ: ' + escapeHtml(q.data.left[userLeftForThisRight]) + '</div>';
        }
      }

      html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
      html3 +=   '<div class="match-left-stack">';
      html3 +=     '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
            +       escapeHtml(q.data.left[matchedLeft])
            +     '</div>';
      html3 +=     hintHtml;
      html3 +=   '</div>';
      html3 += '</div>';
    } else {
      var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

      if (poolLeft !== null && poolLeft !== undefined) {
        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
        html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
              +     escapeHtml(q.data.left[poolLeft])
              +   '</div>';
        html3 += '</div>';
      } else {
        html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
              +   '<span class="slot-placeholder">Перетащите вариант</span>'
              + '</div>';
      }

      poolSlot++;
    }

    html3 += '<div class="matching-gap"></div>';

    // RIGHT (drop target)
    html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
          +   escapeHtml(q.data.right[rightIdx])
          + '</div>';

    html3 += '</div>';
  });

  html3 += '</div>';
  return html3;
}
Вы сказали:
Загруженное изображение
Я заменил но все равно не помогло
ChatGPT сказал:

Думал на протяжении 44s
Судя по твоему скрину, подсветка ошибок работает, значит правильные пары у тебя есть, но рендер всё равно берёт “userPairs”. В 99% случаев это потому, что у тебя:

TEST_DATA.showCorrectAnswers === false
и поэтому вот это условие никогда не включает показ правильного расположения:

var showCorrectLayout = !!(TEST_DATA.showCorrectAnswers && state.feedbackShown);
То есть ты находишься в фидбэке (state.feedbackShown = true), но флаг “показывать правильные ответы” выключен — поэтому “как правильно” не рендерится.

✅ ФИКС (самый простой и правильный для твоей задачи)
Показывать правильное расположение всегда в фидбэке, независимо от TEST_DATA.showCorrectAnswers.

Заменяешь ОДНУ строку:

было
var showCorrectLayout = !!(TEST_DATA.showCorrectAnswers && state.feedbackShown);
станет
var showCorrectLayout = !!state.feedbackShown;
✅ Полностью готовый блок (вставляй целиком вместо твоего matching-рендера)
// MATCHING (Joined Drag & Drop like in UI)
if (q.type === 'matching') {
  // user answer (leftIdx -> rightIdx)
  var userPairs = (answer && typeof answer === 'object') ? answer : {};

  // correct pairs (try several fallbacks)
  var correctPairsArr =
    Array.isArray((q.correct || {}).pairs) ? q.correct.pairs :
    Array.isArray((q.correct || {}).correctPairs) ? q.correct.correctPairs :
    Array.isArray(q.correctPairs) ? q.correctPairs :
    Array.isArray((q.data || {}).pairs) ? q.data.pairs :
    Array.isArray((q.data || {}).correctPairs) ? q.data.correctPairs :
    [];

  // correct maps
  var correctRightToLeft = {}; // right -> left
  var correctLeftToRight = {}; // left -> right
  correctPairsArr.forEach(function(p){
    if (!p) return;
    correctRightToLeft[p.right] = p.left;
    correctLeftToRight[p.left] = p.right;
  });

  // ✅ показываем правильное расположение ВСЕГДА после проверки (в фидбэке)
  var showCorrectLayout = !!state.feedbackShown;

  // render left side: either correct layout or user's
  var pairsForRender = (showCorrectLayout && correctPairsArr.length > 0) ? correctLeftToRight : userPairs;

  var mappingObj = shuffleMapping || {};
  var leftMapping = mappingObj.left ? mappingObj.left : q.data.left.map(function(_, i){ return i; });
  var rightMapping = mappingObj.right ? mappingObj.right : q.data.right.map(function(_, i){ return i; });

  // rightIdx -> leftIdx (what will be shown on the left)
  var rightToLeft = {};
  Object.keys(pairsForRender).forEach(function(k){
    var l = parseInt(k, 10);
    var r = pairsForRender[k];
    if (typeof r === 'number') rightToLeft[r] = l;
  });

  // user: rightIdx -> leftIdx (for "Ваш ответ" hint)
  var userRightToLeft = {};
  Object.keys(userPairs).forEach(function(k){
    var l2 = parseInt(k, 10);
    var r2 = userPairs[k];
    if (typeof r2 === 'number') userRightToLeft[r2] = l2;
  });

  // normalize pool
  if (!state.matchingPools) state.matchingPools = {};
  if (!Array.isArray(state.matchingPools[q.id])) state.matchingPools[q.id] = leftMapping.slice();

  var pool = state.matchingPools[q.id];

  // used left indices based on what we render now
  var usedLeft = {};
  Object.keys(pairsForRender).forEach(function(k){
    var li = parseInt(k, 10);
    if (!Number.isNaN(li)) usedLeft[li] = true;
  });

  var nextPool = [];
  for (var pi = 0; pi < pool.length; pi++) {
    if (!usedLeft[pool[pi]]) nextPool.push(pool[pi]);
  }

  leftMapping.forEach(function(li){
    if (usedLeft[li]) return;
    if (nextPool.indexOf(li) === -1) nextPool.push(li);
  });

  pool = nextPool;
  state.matchingPools[q.id] = pool;

  var html3 = '<div class="matching-board" data-qid="' + escapeHtml(q.id) + '" style="--matchRowH:auto;">';

  var poolSlot = 0;

  rightMapping.forEach(function(rightIdx) {
    var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
    var isJoined = (matchedLeft !== null && matchedLeft !== undefined);

    html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

    // LEFT
    if (isJoined) {
      var hintHtml = '';
      if (showCorrectLayout && correctPairsArr.length > 0) {
        var userLeftForThisRight = userRightToLeft.hasOwnProperty(rightIdx) ? userRightToLeft[rightIdx] : null;
        var correctLeftForThisRight = correctRightToLeft.hasOwnProperty(rightIdx) ? correctRightToLeft[rightIdx] : null;

        if (userLeftForThisRight !== null && correctLeftForThisRight !== null && userLeftForThisRight !== correctLeftForThisRight) {
          hintHtml = '<div class="match-wrong-hint">Ваш ответ: ' + escapeHtml(q.data.left[userLeftForThisRight]) + '</div>';
        }
      }

      html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
      html3 +=   '<div class="match-left-stack">';
      html3 +=     '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
            +       escapeHtml(q.data.left[matchedLeft])
            +     '</div>';
      html3 +=     hintHtml;
      html3 +=   '</div>';
      html3 += '</div>';
    } else {
      var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

      if (poolLeft !== null && poolLeft !== undefined) {
        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
        html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
              +     escapeHtml(q.data.left[poolLeft])
              +   '</div>';
        html3 += '</div>';
      } else {
        html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
              +   '<span class="slot-placeholder">Перетащите вариант</span>'
              + '</div>';
      }

      poolSlot++;
    }

    html3 += '<div class="matching-gap"></div>';

    // RIGHT
    html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
          +   escapeHtml(q.data.right[rightIdx])
          + '</div>';

    html3 += '</div>';
  });

  html3 += '</div>';
  return html3;
}
Важно (если после этого всё равно не покажется)
Тогда причина 100% другая: у тебя после “Принять” не становится state.feedbackShown = true (или рендер происходит до изменения).
Но по скрину видно блок “Неправильно”, значит фидбэк включается — так что твой случай почти наверняка именно TEST_DATA.showCorrectAnswers.

Если хочешь, скинь кусок кода где ты нажимаешь “Принять”/валидируешь (функцию validate/submit), я покажу точно где ставить state.feedbackShown = true; render();.





Файл не выбранФайл не выбран
ChatGPT может допускать ошибки. Проверяйте важную информацию. Смотрите настройки cookie-файлов.

Перейти к содержимому
История чата



Вы сказали:
21-12.md
Файл
Привет изучи
Мне надо сделать так чтобы вопрос ранжирования стал тоже DND
ChatGPT сказал:

Думал на протяжении 1m 8s
Принял. Делаем вопрос “ранжирование” (RANKING) тоже Drag&Drop — т.е. пользователь перетаскивает пункты вверх/вниз и меняет порядок (как сортировка списка), в той же стилистике, что и твой MATCHING. Я ориентируюсь на твою текущую архитектуру со state.answers[qid], renderQuestionInput(q), buildStylesCss() и общими DnD-хендлерами из файла 
21-12

.

Ниже — точечные вставки.

1) CSS: добавь блок для Ranking DnD в buildStylesCss()
Вставь после комментария /* ===== Ranking Questions ===== */ (или замени текущие стили ранжирования, если они есть):

/* ===== Ranking DnD (RANKING) ===== */
.ranking-board{
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-top: 10px;
}

.rank-item{
  user-select:none;
  padding: 14px;
  border-radius: 12px;
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  box-shadow: var(--shadow);
  display:flex;
  align-items:center;
  gap: 10px;
  cursor: grab;
  min-width: 0;
}

.rank-item:active{ cursor: grabbing; }

.rank-grip{
  flex: 0 0 auto;
  display:flex;
  align-items:center;
  opacity: .85;
}

.rank-text{
  min-width: 0;
  white-space: normal;
  color: hsl(var(--foreground));
  opacity: .92;
  font-size: 14px;
  line-height: 1.35;
}

.rank-item.dragging{ opacity: .7; }

.rank-item.is-over{
  outline: 2px solid hsl(var(--primary));
  outline-offset: 2px;
}

/* (необязательно) подсветка после проверки */
.rank-item.correct-answer{
  border-color: hsl(var(--success));
  background: color-mix(in oklab, hsl(var(--success)) 12%, hsl(var(--card)));
}
.rank-item.incorrect-answer{
  border-color: hsl(var(--destructive));
  background: color-mix(in oklab, hsl(var(--destructive)) 10%, hsl(var(--card)));
}
2) Рендер: замени/добавь ветку if (q.type === 'ranking') в renderQuestionInput(q)
Это делает разметку списка, где каждый пункт draggable.

Я предполагаю, что варианты лежат в q.data.items (если у тебя q.data.options / q.data.answers — просто поменяй одно место).

// RANKING (Drag & Drop reorder)
if (q.type === 'ranking') {
  var items = (q.data && Array.isArray(q.data.items)) ? q.data.items : [];

  // ответ храним как массив индексов исходных items: [2,0,1,...]
  var userOrder = Array.isArray(answer) ? answer.slice() : null;

  // если ответа ещё нет — ставим стартовый порядок 0..n-1
  if (!userOrder || userOrder.length !== items.length) {
    userOrder = items.map(function(_, i){ return i; });
    state.answers[q.id] = userOrder;
  }

  var html = '<div class="ranking-board" data-qid="' + escapeHtml(q.id) + '">';

  userOrder.forEach(function(itemIdx, pos){
    var text = (items[itemIdx] != null) ? String(items[itemIdx]) : ('#' + itemIdx);

    html += ''
      + '<div class="rank-item rank-draggable"'
      + ' draggable="true"'
      + ' data-qid="' + escapeHtml(q.id) + '"'
      + ' data-pos="' + pos + '"'
      + ' data-item="' + itemIdx + '">'
      +   '<span class="rank-grip">' + burgerSvgInline() + '</span>'
      +   '<span class="rank-text">' + escapeHtml(text) + '</span>'
      + '</div>';
  });

  html += '</div>';
  return html;
}

// маленький helper для “бургер-иконки”
function burgerSvgInline(){
  return ''
    + '<svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">'
    + '<path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
    + '<path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
    + '<path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
    + '</svg>';
}
3) Логика DnD: добавь initRankingDnD() рядом с твоим initMatchingDnD()
Эта штука слушает события и переставляет элементы в массиве порядка.

function initRankingDnD(){
  var dragPayload = null; // { qid, fromPos, itemIdx }

  function clearOver(){
    document.querySelectorAll('.rank-item.is-over').forEach(function(n){
      n.classList.remove('is-over');
    });
  }

  function getPayload(e){
    try {
      var raw = e.dataTransfer.getData('application/json');
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  function moveInArray(arr, from, to){
    if (from === to) return arr;
    var copy = arr.slice();
    var item = copy.splice(from, 1)[0];
    copy.splice(to, 0, item);
    return copy;
  }

  document.addEventListener('dragstart', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (!el) return;

    // если показан фидбек/правильные ответы — блокируем перетаскивание
    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    var qid = el.getAttribute('data-qid');
    var fromPos = parseInt(el.getAttribute('data-pos'), 10);
    var itemIdx = parseInt(el.getAttribute('data-item'), 10);
    if (!qid || Number.isNaN(fromPos) || Number.isNaN(itemIdx)) return;

    dragPayload = { qid: qid, fromPos: fromPos, itemIdx: itemIdx };
    el.classList.add('dragging');

    try{
      e.dataTransfer.setData('application/json', JSON.stringify(dragPayload));
      e.dataTransfer.effectAllowed = 'move';
    }catch{}
  });

  document.addEventListener('dragend', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (el) el.classList.remove('dragging');
    dragPayload = null;
    clearOver();
  });

  document.addEventListener('dragover', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    // только внутри того же ranking-board
    var qid = over.getAttribute('data-qid');
    if (!qid) return;

    e.preventDefault();
    clearOver();
    over.classList.add('is-over');

    try{ e.dataTransfer.dropEffect = 'move'; }catch{}
  });

  document.addEventListener('drop', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    e.preventDefault();
    over.classList.remove('is-over');

    var p = getPayload(e) || dragPayload;
    if (!p) return;

    var qid = over.getAttribute('data-qid');
    if (!qid || qid !== p.qid) return;

    var toPos = parseInt(over.getAttribute('data-pos'), 10);
    if (Number.isNaN(toPos)) return;

    var current = state.answers[qid];
    if (!Array.isArray(current)) return;

    // из-за рендера pos актуальный, можно двигать напрямую
    var next = moveInArray(current, p.fromPos, toPos);
    state.answers[qid] = next;

    render();
  });
}
И не забудь вызвать один раз (там же, где ты вызываешь initMatchingDnD()):

initRankingDnD();
Как это будет хранить ответ
state.answers[qid] станет массивом индексов, например: [2,0,1] — значит на 1 месте был item #2, потом #0, потом #1. Это удобно проверять с q.correct.order (если у тебя “правильный порядок” хранится так же).

Если скажешь, как у тебя в данных реально называется массив вариантов (q.data.items или другое) и как выглядит правильный ответ (q.correct.order?), я подгоню 2 строки под твой формат, чтобы проверка/фидбек работали идеально.


Источники
Вы сказали:
function buildAppJs(testJson: string): string {
  return 
// Embedded test data
var TEST_DATA = ${testJson};

// App state
var state = {
  phase: 'start',
  currentIndex: 0,
  answers: {},
  variant: null,
  flatQuestions: [],
  shuffleMappings: {},
  timerInterval: null,
  remainingSeconds: null,
  timeExpired: false,
  submitted: false,
  answerConfirmed: false,
  feedbackShown: false
};
var scormFinished = false;

// Initialize
window.onload = function() {
  SCORM.init();
  window.addEventListener('beforeunload', function() {
    try { SCORM.commit(); } catch (e) {}
    try { SCORM.terminate(); } catch (e) {}
  });
  bindRankingClicksOnce();
  bindMatchingDnDOnce();
  generateVariant();
  render();
  window.addEventListener('resize', function(){ syncMatchingHeights(); });
};

var __matchHeightRAF = 0;
function syncMatchingHeights() {
  try {
    if (__matchHeightRAF) cancelAnimationFrame(__matchHeightRAF);
  } catch (e) {}

  __matchHeightRAF = requestAnimationFrame(function() {
    var roots = document.querySelectorAll('.matching-board');
    for (var i = 0; i < roots.length; i++) {
      var root = roots[i];
      if (!root || !root.style) continue;

      // reset to auto for measurement
      root.style.setProperty('--matchRowH', 'auto');

      // measure after next frame so layout is updated
      (function(r) {
        requestAnimationFrame(function() {
          var nodes = r.querySelectorAll('.match-tile, .match-empty');
          var maxH = 0;
          for (var j = 0; j < nodes.length; j++) {
            var h = nodes[j].offsetHeight || 0;
            if (h > maxH) maxH = h;
          }
          if (maxH < 44) maxH = 56; // safety
          r.style.setProperty('--matchRowH', String(maxH) + 'px');
        });
      })(root);
    }
  });
}

var __matchDndBound = false;

function bindMatchingDnDOnce() {
  if (__matchDndBound) return;
  __matchDndBound = true;

  function closestByClass(node, cls) {
    var el = node;
    while (el && el !== document) {
      if (el.classList && el.classList.contains(cls)) return el;
      el = el.parentNode;
    }
    return null;
  }

  function parsePayloadFromEvent(e) {
    var raw = '';
    try { raw = e.dataTransfer.getData('application/json'); } catch (err) {}
    if (!raw) {
      try { raw = e.dataTransfer.getData('text/plain'); } catch (err2) {}
    }
    if (!raw) return null;

    // JSON first
    try {
      var obj = JSON.parse(raw);
      if (obj && obj.qid) return obj;
    } catch (e1) {}

    // fallback: qid|leftIdx|from|poolIndex|rightIdx
    var parts = String(raw).split('|');
    if (parts.length < 2) return null;

    var qid = parts[0];
    var leftIdx = parseInt(parts[1], 10);
    if (!qid || Number.isNaN(leftIdx)) return null;

    var payload = { qid: qid, leftIdx: leftIdx, from: parts[2] || 'pool' };
    if (parts[3]) {
      var pi = parseInt(parts[3], 10);
      if (!Number.isNaN(pi)) payload.poolIndex = pi;
    }
    if (parts[4]) {
      var ri = parseInt(parts[4], 10);
      if (!Number.isNaN(ri)) payload.rightIdx = ri;
    }
    return payload;
  }

  function getCurrentQuestionById(qid) {
    var current = state.flatQuestions[state.currentIndex] && state.flatQuestions[state.currentIndex].question;
    if (current && String(current.id) === String(qid)) return current;

    for (var i = 0; i < state.flatQuestions.length; i++) {
      var q = state.flatQuestions[i].question;
      if (q && String(q.id) === String(qid)) return q;
    }
    return null;
  }

  function normalizePool(qid, leftMapping, ans) {
    if (!state.matchingPools) state.matchingPools = {};
    if (!Array.isArray(state.matchingPools[qid])) state.matchingPools[qid] = leftMapping.slice();

    var pool = state.matchingPools[qid];

    // used left
    var used = {};
    Object.keys(ans || {}).forEach(function(k) {
      var li = parseInt(k, 10);
      if (!Number.isNaN(li)) used[li] = true;
    });

    // remove used from pool
    var next = [];
    for (var i = 0; i < pool.length; i++) {
      var li2 = pool[i];
      if (!used[li2]) next.push(li2);
    }

    // add missing unused in leftMapping order
    for (var j = 0; j < leftMapping.length; j++) {
      var li3 = leftMapping[j];
      if (used[li3]) continue;
      if (next.indexOf(li3) === -1) next.push(li3);
    }

    state.matchingPools[qid] = next;
    return next;
  }

  function removeFromPool(pool, leftIdx, poolIndex) {
    if (!Array.isArray(pool)) return -1;

    if (typeof poolIndex === 'number' && poolIndex >= 0 && poolIndex < pool.length && pool[poolIndex] === leftIdx) {
      pool.splice(poolIndex, 1);
      return poolIndex;
    }

    var idx = pool.indexOf(leftIdx);
    if (idx >= 0) {
      pool.splice(idx, 1);
      return idx;
    }

    return -1;
  }

  function insertIntoPool(pool, leftIdx, index) {
    if (!Array.isArray(pool)) return;
    var i = (typeof index === 'number') ? index : pool.length;
    if (i < 0) i = 0;
    if (i > pool.length) i = pool.length;
    pool.splice(i, 0, leftIdx);
  }

  function leftForRight(ans, rightIdx) {
    var keys = Object.keys(ans || {});
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (ans[k] === rightIdx) return parseInt(k, 10);
    }
    return null;
  }

  function removeLeftFromAnswers(ans, leftIdx) {
    if (!ans || typeof ans !== 'object') return;
    if (ans.hasOwnProperty(leftIdx)) delete ans[leftIdx];
    if (ans.hasOwnProperty(String(leftIdx))) delete ans[String(leftIdx)];
  }

  // dragstart
  document.addEventListener('dragstart', function(e) {
    var card = closestByClass(e.target, 'match-chip');
    if (!card) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
      e.preventDefault();
      return;
    }

    var qid = card.getAttribute('data-qid');
    var left = parseInt(card.getAttribute('data-left'), 10);
    if (!qid || Number.isNaN(left)) return;

    var from = card.getAttribute('data-from') || 'pool';
    var payload = { qid: qid, leftIdx: left, from: from };

    var piStr = card.getAttribute('data-pool-index');
    if (piStr !== null && piStr !== '') {
      var pi = parseInt(piStr, 10);
      if (!Number.isNaN(pi)) payload.poolIndex = pi;
    }

    var riStr = card.getAttribute('data-right');
    if (riStr !== null && riStr !== '') {
      var ri = parseInt(riStr, 10);
      if (!Number.isNaN(ri)) payload.rightIdx = ri;
    }

    try {
      e.dataTransfer.setData('application/json', JSON.stringify(payload));
      e.dataTransfer.setData(
        'text/plain',
        payload.qid + '|' + payload.leftIdx + '|' + payload.from + '|' +
        (payload.poolIndex !== undefined ? payload.poolIndex : '') + '|' +
        (payload.rightIdx !== undefined ? payload.rightIdx : '')
      );
      e.dataTransfer.effectAllowed = 'move';
    } catch (err) {}
  });

  // dragover
  document.addEventListener('dragover', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');

    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    dropEl.classList.add('is-over');
    try { e.dataTransfer.dropEffect = 'move'; } catch (err) {}
  });

  document.addEventListener('dragleave', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;
    dropEl.classList.remove('is-over');
  });

  // drop
  document.addEventListener('drop', function(e) {
    var rightDrop = closestByClass(e.target, 'match-drop-right');
    var leftDrop = closestByClass(e.target, 'match-drop-left');
    var dropEl = rightDrop || leftDrop;
    if (!dropEl) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    dropEl.classList.remove('is-over');

    var payload = parsePayloadFromEvent(e);
    if (!payload || !payload.qid || Number.isNaN(payload.leftIdx)) return;

    var q = getCurrentQuestionById(payload.qid);
    if (!q || q.type !== 'matching') return;

    var ans = (state.answers[payload.qid] && typeof state.answers[payload.qid] === 'object') ? state.answers[payload.qid] : {};

    var shuffleMapping = state.shuffleMappings[q.id] || {};
    var leftMapping = shuffleMapping.left ? shuffleMapping.left : q.data.left.map(function(_, i){ return i; });

    var pool = normalizePool(payload.qid, leftMapping, ans);

    var poolSlotStr = dropEl.getAttribute('data-pool-slot');
    var targetRightStr = dropEl.getAttribute('data-right');
    var isPoolDrop = (poolSlotStr !== null && poolSlotStr !== '');

    if (isPoolDrop) {
      var targetSlot = parseInt(poolSlotStr, 10);
      if (Number.isNaN(targetSlot)) return;

      if (payload.from === 'pool') {
        var removedAt = removeFromPool(pool, payload.leftIdx, payload.poolIndex);
        if (removedAt >= 0 && removedAt < targetSlot) targetSlot = targetSlot - 1;
      } else {
        removeLeftFromAnswers(ans, payload.leftIdx);
      }

      insertIntoPool(pool, payload.leftIdx, targetSlot);

      state.answers[payload.qid] = ans;
      state.matchingPools[payload.qid] = pool;
      render();
      return;
    }

    var targetRight = parseInt(targetRightStr, 10);
    if (Number.isNaN(targetRight)) return;

    if (payload.from === 'pool') {
      removeFromPool(pool, payload.leftIdx, payload.poolIndex);
    } else {
      removeLeftFromAnswers(ans, payload.leftIdx);
    }

    var oldLeft = leftForRight(ans, targetRight);
    if (oldLeft !== null && !Number.isNaN(oldLeft)) {
      removeLeftFromAnswers(ans, oldLeft);

      if (payload.from === 'pool' && typeof payload.poolIndex === 'number') {
        insertIntoPool(pool, oldLeft, payload.poolIndex);
      } else {
        insertIntoPool(pool, oldLeft, pool.length);
      }
    }

    ans[payload.leftIdx] = targetRight;

    Object.keys(ans).forEach(function(k) {
      var li = parseInt(k, 10);
      if (li !== payload.leftIdx && ans[k] === targetRight) delete ans[k];
    });

    state.answers[payload.qid] = ans;
    state.matchingPools[payload.qid] = pool;
    render();
  });

  // dblclick matched -> return to pool
  document.addEventListener('dblclick', function(e) {
    var card = closestByClass(e.target, 'match-chip');
    if (!card) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    var from = card.getAttribute('data-from');
    if (from !== 'match') return;

    var qid = card.getAttribute('data-qid');
    var leftIdx = parseInt(card.getAttribute('data-left'), 10);
    if (!qid || Number.isNaN(leftIdx)) return;

    var q = getCurrentQuestionById(qid);
    if (!q || q.type !== 'matching') return;

    var ans = (state.answers[qid] && typeof state.answers[qid] === 'object') ? state.answers[qid] : {};
    var shuffleMapping = state.shuffleMappings[q.id] || {};
    var leftMapping = shuffleMapping.left ? shuffleMapping.left : q.data.left.map(function(_, i){ return i; });

    var pool = normalizePool(qid, leftMapping, ans);

    removeLeftFromAnswers(ans, leftIdx);
    insertIntoPool(pool, leftIdx, pool.length);

    state.answers[qid] = ans;
    state.matchingPools[qid] = pool;
    render();
  });
}

var __rankClickBound = false;

function bindRankingClicksOnce() {
  if (__rankClickBound) return;
  __rankClickBound = true;

  document.addEventListener('click', function(e) {
    var el = e.target;

    // fallback если closest нет
    while (el && el !== document) {
      if (el.classList && el.classList.contains('rank-btn')) break;
      el = el.parentNode;
    }
    if (!el || el === document) return;

    if (el.disabled) return;

    var qId = el.getAttribute('data-qid');
    var pos = parseInt(el.getAttribute('data-pos'), 10);
    var dir = parseInt(el.getAttribute('data-dir'), 10);

    if (!qId || Number.isNaN(pos) || Number.isNaN(dir)) return;

    moveRank(qId, pos, dir);
  });
}

function initTimer() {
  if (TEST_DATA.timeLimitMinutes && TEST_DATA.timeLimitMinutes > 0) {
    state.remainingSeconds = TEST_DATA.timeLimitMinutes * 60;
    state.timerInterval = setInterval(updateTimer, 1000);
  }
}

function updateTimer() {
  if (state.submitted) {
    if (state.timerInterval) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
    }
    return;
  }
  
  if (state.remainingSeconds === null || state.remainingSeconds <= 0) {
    if (state.timerInterval) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
    }
    return;
  }
  
  state.remainingSeconds--;
  updateTimerDisplay();
  
  if (state.remainingSeconds <= 0 && !state.submitted) {
    state.timeExpired = true;
    if (state.timerInterval) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
    }
    submit(true); // ✅ форсируем завершение даже без ответа на текущий вопрос
  }
}

function updateTimerDisplay() {
  var timerEl = document.getElementById('timer-display');
  if (timerEl && state.remainingSeconds !== null) {
    var mins = Math.floor(state.remainingSeconds / 60);
    var secs = state.remainingSeconds % 60;
    timerEl.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;
    if (state.remainingSeconds <= 60) {
      timerEl.style.color = '#dc2626';
      timerEl.style.fontWeight = 'bold';
    }
  }
}

function formatTime(seconds) {
  var mins = Math.floor(seconds / 60);
  var secs = seconds % 60;
  return mins + ':' + (secs < 10 ? '0' : '') + secs;
}

function generateVariant() {
  state.variant = { sections: [] };
  state.flatQuestions = [];
  state.shuffleMappings = {}; // Store shuffle mappings for each question

  TEST_DATA.sections.forEach(function(section) {
    var questions = shuffle(section.questions.slice()).slice(0, section.drawCount);
    state.variant.sections.push({
      topicId: section.topicId,
      topicName: section.topicName,
      questionIds: questions.map(function(q) { return q.id; })
    });
    questions.forEach(function(q) {
      // Generate shuffle mappings for each question type
      if (q.type === 'single' || q.type === 'multiple') {
        var optCount = q.data.options ? q.data.options.length : 0;
        if (optCount > 0) {
          state.shuffleMappings[q.id] = createShuffleMapping(optCount);
        }
      } else if (q.type === 'matching') {
        var leftCount = q.data.left ? q.data.left.length : 0;
        var rightCount = q.data.right ? q.data.right.length : 0;
        if (leftCount > 0 && rightCount > 0) {
          state.shuffleMappings[q.id] = {
            left: createShuffleMapping(leftCount),
            right: createShuffleMapping(rightCount)
          };
        }
      } else if (q.type === 'ranking') {
        var itemCount = q.data.items ? q.data.items.length : 0;
        if (itemCount > 0) {
          state.shuffleMappings[q.id] = createShuffleMapping(itemCount);
          // Initialize ranking with shuffled order
          if (!state.answers[q.id]) {
            state.answers[q.id] = state.shuffleMappings[q.id].slice();
          }
        }
      }
      
      state.flatQuestions.push({
        question: q,
        topicId: section.topicId,
        topicName: section.topicName
      });
    });
  });
  state.flatQuestions = shuffle(state.flatQuestions);
}

function createShuffleMapping(length) {
  var indices = [];
  for (var i = 0; i < length; i++) {
    indices.push(i);
  }
  return shuffle(indices.slice());
}

function shuffle(arr) {
  for (var i = arr.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
  return arr;
}

function render() {
  if (state.phase === 'start') {
    renderStartPage();
    return;
  }
  
  var app = document.getElementById('app');
  var total = state.flatQuestions.length;
  var current = state.currentIndex;

  if (current >= total) {
    renderResults();
    return;
  }

  var qData = state.flatQuestions[current];
  var q = qData.question;
  var progress = ((current + 1) / total) * 100;

  var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">';
  html += '<h1 style="margin:0">' + escapeHtml(TEST_DATA.title) + '</h1>';
  if (state.remainingSeconds !== null) {
    var timerClass = state.remainingSeconds <= 60 ? 'style="color:#dc2626;font-weight:bold;font-size:18px;"' : 'style="color:#666;font-size:18px;"';
    html += '<div id="timer-display" ' + timerClass + '>' + formatTime(state.remainingSeconds) + '</div>';
  }
  html += '</div>';
  html += '<div class="progress-bar"><div class="progress-fill" style="width:' + progress + '%"></div></div>';
  html += '<div class="card">';
  html += '<div style="color:#666;margin-bottom:8px;">Вопрос ' + (current + 1) + ' из ' + total + ' | ' + escapeHtml(qData.topicName) + '</div>';
  html += '<div class="question-text">' + escapeHtml(q.prompt) + '</div>';
  html += renderQuestionMedia(q);
  html += renderQuestionInput(q);
  
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
    var answer = state.answers[q.id];
    var scoreRatio = checkAnswer(q, answer);
    var isCorrect = scoreRatio === 1;
    var statusColor = isCorrect ? '#16a34a' : '#dc2626';
    var statusText = isCorrect ? 'Правильно!' : (scoreRatio > 0 ? 'Частично правильно' : 'Неправильно');
    
    html += '<div style="margin-top:16px;padding:12px;border-radius:8px;background:' + (isCorrect ? '#dcfce7' : '#fee2e2') + ';border:1px solid ' + statusColor + ';">';
    html += '<div style="font-weight:600;color:' + statusColor + ';margin-bottom:4px;">' + statusText + '</div>';
    
    var feedbackText = null;
    if (q.feedbackMode === 'conditional') {
      feedbackText = isCorrect ? q.feedbackCorrect : q.feedbackIncorrect;
    } else {
      feedbackText = q.feedback;
    }
    
    if (feedbackText) {
      html += '<div style="color:#333;font-size:14px;">' + escapeHtml(feedbackText) + '</div>';
    }
    html += '</div>';
  }
  
  html += '</div>';
  html += '<div class="navigation" style="justify-content:flex-end">';
  
  if (TEST_DATA.showCorrectAnswers && !state.feedbackShown) {
    html += '<button class="btn" onclick="confirmAnswer()">Принять</button>';
  } else if (current < total - 1) {
    html += '<button class="btn" onclick="next()">Далее</button>';
  } else {
    html += '<button class="btn" onclick="submit()">Завершить тест</button>';
  }
  html += '</div>';

  app.innerHTML = html;
  syncMatchingHeights();
}

function renderStartPage() {
  var app = document.getElementById('app');
  var used = getAttemptsUsed();
  var hasLimit = !!TEST_DATA.maxAttempts;
  var left = hasLimit ? Math.max(0, TEST_DATA.maxAttempts - used) : null;
  
  var iconQuestions = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg>';
  var iconPass = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>';
  var iconTime = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
  var iconAttempts = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>';
  
  var html = '<div class="start-page" style="max-width:600px;margin:40px auto;padding:0 18px;">';
  
  // Header card
  html += '<div class="card" style="padding:32px;text-align:center;margin-bottom:24px;background:hsl(var(--card));border:1px solid hsl(var(--border));">';
  html += '<h1 style="color:hsl(var(--foreground));margin:0;font-size:28px;font-weight:700;">' + escapeHtml(TEST_DATA.title) + '</h1>';
  if (TEST_DATA.description) {
    html += '<p style="color:hsl(var(--muted-foreground));margin-top:12px;margin-bottom:0;font-size:15px;">' + escapeHtml(TEST_DATA.description) + '</p>';
  }
  html += '</div>';
  
  // Info section
  html += '<div class="card" style="padding:24px;background:hsl(var(--card));border:1px solid hsl(var(--border));">';
  html += '<h2 style="margin:0 0 20px 0;font-size:18px;font-weight:700;color:hsl(var(--foreground));">Информация о тесте</h2>';
  
  html += '<div style="display:grid;gap:12px;">';
  
  // Количество вопросов
  html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
  html += '<div style="flex-shrink:0;color:#4f46e5;">' + iconQuestions + '</div>';
  html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Количество вопросов</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' + TEST_DATA.totalQuestions + '</div></div>';
  html += '</div>';
  
  // Проходной балл
  html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
  html += '<div style="flex-shrink:0;color:#16a34a;">' + iconPass + '</div>';
  html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Проходной балл</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' + TEST_DATA.passPercent + '%</div></div>';
  html += '</div>';
  
  // Ограничение времени
  if (TEST_DATA.timeLimitMinutes) {
    html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
    html += '<div style="flex-shrink:0;color:#f59e0b;">' + iconTime + '</div>';
    html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Ограничение времени</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' + TEST_DATA.timeLimitMinutes + ' минут</div></div>';
    html += '</div>';
  }
  
  // Количество попыток
  if (TEST_DATA.maxAttempts) {
    html += '<div style="display:flex;align-items:center;gap:12px;padding:16px;background:hsl(var(--muted));border-radius:12px;border:1px solid hsl(var(--border));">';
    html += '<div style="flex-shrink:0;color:#8b5cf6;">' + iconAttempts + '</div>';
    html += '<div style="flex:1;"><div style="font-weight:600;color:hsl(var(--foreground));font-size:14px;">Попытки</div><div style="color:hsl(var(--muted-foreground));font-size:13px;margin-top:2px;">' 
    + (hasLimit ? ('осталось ' + left + ' из ' + TEST_DATA.maxAttempts) : 'без ограничений')
    + '</div></div>';
    html += '</div>';
  }
  
  html += '</div>';
  
  // Custom content
  if (TEST_DATA.startPageContent) {
    html += '<div style="margin-top:20px;padding:16px;background:hsl(var(--muted));border-radius:12px;border-left:4px solid hsl(var(--primary));border:1px solid hsl(var(--border));">';
    html += '<div style="color:hsl(var(--foreground));font-size:14px;line-height:1.6;">' + escapeHtml(TEST_DATA.startPageContent) + '</div>';
    html += '</div>';
  }
  
  // Start button
  var noAttempts = hasLimit && left <= 0;

  html += '<div style="margin-top:24px;text-align:center;">';
  html += '<button class="btn" '
    + (noAttempts ? 'disabled ' : '')
    + 'onclick="' + (noAttempts ? 'return false;' : 'startTest()') + '" '
    + 'style="padding:14px 40px;font-size:16px;font-weight:600;'
    + (noAttempts ? 'opacity:.55;cursor:not-allowed;' : '')
    + '">'
    + (noAttempts ? 'Попытки закончились' : 'Начать тестирование')
    + '</button>';
  html += '</div>';

  // закрываем карточку и обёртку страницы
  html += '</div></div>';
  
  app.innerHTML = html;
}

function startTest() {
  if (!hasAttemptsLeft()) {
    showToast('Попытки закончились', 'warn');
    return;
  }

  // фиксируем начало попытки
  var ok = registerAttemptStart();
  if (!ok) {
    showToast('Попытки закончились', 'warn');
    return;
  }

  state.phase = 'question';
  initTimer();
  render();
}


function showToast(message, kind) {
  var root = document.getElementById('toast-root');
  if (!root) return;

  var el = document.createElement('div');
  el.className = 'toast' + (kind ? (' ' + kind) : '');
  el.textContent = message;

  root.appendChild(el);

  setTimeout(function() {
    if (el && el.parentNode) el.parentNode.removeChild(el);
  }, 2500);
}

function hasAnswer(q, answer) {
  if (!q) return true;

  if (q.type === 'single') return typeof answer === 'number';
  if (q.type === 'multiple') return Array.isArray(answer) && answer.length > 0;

  if (q.type === 'matching') {
    if (!answer || typeof answer !== 'object') return false;
    var need = (q.data && Array.isArray(q.data.left)) ? q.data.left.length : 0;
    var keys = Object.keys(answer);
    return keys.length === need && keys.every(function(k) {
      return typeof answer[k] === 'number';
    });
  }

  // ranking: порядок всегда есть (дефолтный тоже), считаем ответом
  if (q.type === 'ranking') return true;

  return answer !== undefined && answer !== null;
}

function requireAnswerOrToast() {
  var fq = state.flatQuestions[state.currentIndex];
  if (!fq) return true;

  var q = fq.question;
  var answer = state.answers[q.id];

  if (!hasAnswer(q, answer)) {
    showToast('Сначала ответьте на вопрос', 'warn');
    return false;
  }
  return true;
}

function confirmAnswer() {
  if (!requireAnswerOrToast()) return;
  state.feedbackShown = true;
  
  // Вместо render() - обновляем DOM точечно
  var fq = state.flatQuestions[state.currentIndex];
  var q = fq.question;
  var answer = state.answers[q.id];
  var scoreRatio = checkAnswer(q, answer);
  var isCorrect = scoreRatio === 1;
  
  // Блокируем варианты ответов (добавляем disabled и меняем курсор)
  lockAnswerOptions(q);
  
  // Показываем правильные/неправильные ответы
  if (TEST_DATA.showCorrectAnswers) {
    highlightCorrectAnswers(q, answer);
  }
  
  // Вставляем feedback после вопроса
  insertFeedback(q, isCorrect, scoreRatio);
  
  // Меняем кнопку "Принять" на "Далее"/"Завершить"
  updateNavigationButton();
}

function lockAnswerOptions(q) {
  // кликабельные .option
  var options = document.querySelectorAll('.option');
  options.forEach(function(opt) {
    opt.style.cursor = 'default';
    opt.onclick = null;
  });

  // все инпуты
  var inputs = document.querySelectorAll('input');
  inputs.forEach(function(input) {
    input.disabled = true;
  });

  // все селекты (matching)
  var selects = document.querySelectorAll('select');
  selects.forEach(function(sel) {
    sel.disabled = true;
  });

  // ranking buttons
  var rankButtons = document.querySelectorAll('.ranking-controls button');
  rankButtons.forEach(function(btn) {
    btn.disabled = true;
  });
}


function highlightCorrectAnswers(q, answer) {
  var correct = q.correct || {};
  
  if (q.type === 'single') {
    var correctIndex = correct.correctIndex;
    var options = document.querySelectorAll('.option');
    options.forEach(function(opt) {
      var dataIndex = opt.getAttribute('data-index');
      if (dataIndex !== null) {
        var idx = parseInt(dataIndex, 10);
        if (idx === correctIndex) {
          opt.classList.add('correct-answer');
        } else if (idx === answer) {
          opt.classList.add('incorrect-answer');
        }
      }
    });
  }
  
  if (q.type === 'multiple') {
    var correctSet = correct.correctIndices || [];
    var selectedSet = Array.isArray(answer) ? answer : [];
    var options = document.querySelectorAll('.option');
    options.forEach(function(opt) {
      var dataIndex = opt.getAttribute('data-index');
      if (dataIndex !== null) {
        var idx = parseInt(dataIndex, 10);
        var isCorrect = correctSet.indexOf(idx) !== -1;
        var isSelected = selectedSet.indexOf(idx) !== -1;
        
        if (isCorrect) {
          opt.classList.add('correct-answer');
        } else if (isSelected && !isCorrect) {
          opt.classList.add('incorrect-answer');
        }
      }
    });
  }
  
  // MATCHING
  if (q.type === 'matching') {
    highlightMatching(q, answer);
    return;
  }

  // RANKING
  if (q.type === 'ranking') {
    highlightRanking(q, answer);
    return;
  }
}

function highlightMatching(q, answer) {
  var pairs = (answer && typeof answer === 'object') ? answer : {};
  var correctPairsArr = Array.isArray((q.correct || {}).pairs) ? q.correct.pairs : [];

  // correct: rightIdx -> leftIdx
  var correctRightToLeft = {};
  correctPairsArr.forEach(function(p) { correctRightToLeft[p.right] = p.left; });

  // user: rightIdx -> leftIdx
  var userRightToLeft = {};
  Object.keys(pairs).forEach(function(k){
    var l = parseInt(k, 10);
    var r = pairs[k];
    if (typeof r === 'number') userRightToLeft[r] = l;
  });

  document.querySelectorAll('.matching-line[data-qid="' + q.id + '"]').forEach(function(line) {
    line.classList.remove('correct-answer', 'incorrect-answer');

    var rightAttr = line.getAttribute('data-right');
    if (rightAttr === null) return;

    var rightIdx = parseInt(rightAttr, 10);
    if (Number.isNaN(rightIdx)) return;

    if (!userRightToLeft.hasOwnProperty(rightIdx)) return;

    var userLeft = userRightToLeft[rightIdx];
    var correctLeft = correctRightToLeft[rightIdx];

    if (Number(userLeft) === Number(correctLeft)) {
      line.classList.add('correct-answer');
    } else {
      line.classList.add('incorrect-answer');
    }
  });
}

function highlightRanking(q, answer) {
  var order = Array.isArray(answer) ? answer : [];
  var correctOrder = Array.isArray((q.correct || {}).correctOrder) ? q.correct.correctOrder : [];

  if (!order.length || !correctOrder.length) return;

  document.querySelectorAll('#ranking_' + q.id + ' .ranking-item').forEach(function(row, pos) {
    row.classList.remove('correct-answer', 'incorrect-answer');

    var itemIdx = order[pos];
    var ok = (itemIdx === correctOrder[pos]);

    var slot = row.querySelector('.rank-hint-slot');
    if (slot) slot.textContent = '';

    if (ok) {
      row.classList.add('correct-answer');
      return;
    }

    row.classList.add('incorrect-answer');

    // где должен быть этот itemIdx
    var shouldBePos = correctOrder.indexOf(itemIdx);
    if (shouldBePos >= 0 && slot) {
      slot.textContent = '(Должен быть: ' + (shouldBePos + 1) + ')';
    }
  });
}

function insertFeedback(q, isCorrect, scoreRatio) {
  // Проверяем что feedback ещё не вставлен
  var existing = document.querySelector('.feedback-block');
  if (existing) return;
  
  var statusColor = isCorrect ? '#16a34a' : '#dc2626';
  var statusBg = isCorrect ? '#dcfce7' : '#fee2e2';
  var statusText = isCorrect ? 'Правильно!' : (scoreRatio > 0 ? 'Частично правильно' : 'Неправильно');
  
  var feedbackText = null;
  if (q.feedbackMode === 'conditional') {
    feedbackText = isCorrect ? q.feedbackCorrect : q.feedbackIncorrect;
  } else {
    feedbackText = q.feedback;
  }
  
  var html = '<div class="feedback-block" style="margin-top:16px;padding:12px;border-radius:8px;background:' + statusBg + ';border:1px solid ' + statusColor + ';">';
  html += '<div style="font-weight:600;color:' + statusColor + ';margin-bottom:4px;">' + statusText + '</div>';
  
  if (feedbackText) {
    html += '<div style="color:#333;font-size:14px;">' + escapeHtml(feedbackText) + '</div>';
  }
  html += '</div>';
  
  // Вставляем после .card
  var card = document.querySelector('.card');
  if (card) {
    card.insertAdjacentHTML('beforeend', html);
  }
}

function updateNavigationButton() {
  var navBtn = document.querySelector('.navigation .btn');
  if (!navBtn) return;
  
  var total = state.flatQuestions.length;
  var current = state.currentIndex;
  
  if (current < total - 1) {
    navBtn.textContent = 'Далее';
    navBtn.onclick = next;
  } else {
    navBtn.textContent = 'Завершить тест';
    navBtn.onclick = submit;
  }
}

function renderQuestionMedia(q) {
  if (!q.mediaUrl || !q.mediaType) return '';
  
  if (q.mediaType === 'image') {
    return '<div class="question-media"><img src="' + escapeHtml(q.mediaUrl) + '" alt="Question media" style="max-height:250px;max-width:100%;margin:16px auto;display:block;border-radius:8px;"></div>';
  }
  if (q.mediaType === 'audio') {
    return '<div class="question-media"><audio controls style="width:100%;margin:16px 0;"><source src="' + escapeHtml(q.mediaUrl) + '">Your browser does not support audio.</audio></div>';
  }
  if (q.mediaType === 'video') {
    return '<div class="question-media"><video controls style="max-height:250px;max-width:100%;margin:16px auto;display:block;border-radius:8px;"><source src="' + escapeHtml(q.mediaUrl) + '">Your browser does not support video.</video></div>';
  }
  return '';
}

function renderQuestionInput(q) {
  var answer = state.answers[q.id];
  var locked = TEST_DATA.showCorrectAnswers && state.feedbackShown;
  var correct = q.correct || {};
  var shuffleMapping = state.shuffleMappings[q.id];

  // SINGLE
  if (q.type === 'single') {
    var correctIndex = (typeof correct.correctIndex === 'number') ? correct.correctIndex : -1;
    var displayOrder = shuffleMapping || q.data.options.map(function(_, i) { return i; });
    var html = '';

    displayOrder.forEach(function(originalIndex) {
      var selected = answer === originalIndex ? 'selected' : '';
      var correctClass = '';
      if (locked) {
        if (originalIndex === correctIndex) correctClass = ' correct-answer';
        else if (answer === originalIndex && originalIndex !== correctIndex) correctClass = ' incorrect-answer';
      }
      var clickHandler = locked ? '' : 'onclick="selectSingle(\\'' + q.id + '\\',' + originalIndex + ')"';
      html += '<div class="option ' + selected + correctClass + '" data-index="' + originalIndex + '" ' + clickHandler + ' style="' + (locked ? 'cursor:default;' : '') + '">';
      html += '<input type="radio" name="q_' + q.id + '" ' + (answer === originalIndex ? 'checked' : '') + ' ' + (locked ? 'disabled' : '') + '>';
      html += escapeHtml(q.data.options[originalIndex]) + '</div>';
    });
    return html;
  }

  // MULTIPLE
  if (q.type === 'multiple') {
    var selectedArr = Array.isArray(answer) ? answer : [];
    var correctSet = Array.isArray(correct.correctIndices) ? correct.correctIndices : [];
    var displayOrder2 = shuffleMapping || q.data.options.map(function(_, i) { return i; });
    var html2 = '';

    displayOrder2.forEach(function(originalIndex) {
      var isSelected = selectedArr.indexOf(originalIndex) !== -1;
      var isCorrect = correctSet.indexOf(originalIndex) !== -1;
      var correctClass2 = '';
      if (locked) {
        if (isCorrect) correctClass2 = ' correct-answer';
        else if (isSelected && !isCorrect) correctClass2 = ' incorrect-answer';
      }
      var clickHandler2 = locked ? '' : 'onclick="toggleMultiple(\\'' + q.id + '\\',' + originalIndex + ')"';
      html2 += '<div class="option ' + (isSelected ? 'selected' : '') + correctClass2 + '" data-index="' + originalIndex + '" ' + clickHandler2 + ' style="' + (locked ? 'cursor:default;' : '') + '">';
      html2 += '<input type="checkbox" ' + (isSelected ? 'checked' : '') + ' ' + (locked ? 'disabled' : '') + '>';
      html2 += escapeHtml(q.data.options[originalIndex]) + '</div>';
    });
    return html2;
  }

  // MATCHING (Joined Drag & Drop like in UI)
  if (q.type === 'matching') {
    var pairs = (answer && typeof answer === 'object') ? answer : {};

    var mappingObj = shuffleMapping || {};
    var leftMapping = mappingObj.left ? mappingObj.left : q.data.left.map(function(_, i){ return i; });
    var rightMapping = mappingObj.right ? mappingObj.right : q.data.right.map(function(_, i){ return i; });

    // rightIdx -> leftIdx
    var rightToLeft = {};
    Object.keys(pairs).forEach(function(k){
      var l = parseInt(k, 10);
      var r = pairs[k];
      if (typeof r === 'number') rightToLeft[r] = l;
    });

    // normalize pool
    if (!state.matchingPools) state.matchingPools = {};
    if (!Array.isArray(state.matchingPools[q.id])) state.matchingPools[q.id] = leftMapping.slice();

    var pool = state.matchingPools[q.id];

    var usedLeft = {};
    Object.keys(pairs).forEach(function(k){
      var li = parseInt(k, 10);
      if (!Number.isNaN(li)) usedLeft[li] = true;
    });

    var nextPool = [];
    for (var pi = 0; pi < pool.length; pi++) {
      if (!usedLeft[pool[pi]]) nextPool.push(pool[pi]);
    }

    leftMapping.forEach(function(li){
      if (usedLeft[li]) return;
      if (nextPool.indexOf(li) === -1) nextPool.push(li);
    });

    pool = nextPool;
    state.matchingPools[q.id] = pool;

    var html3 = '<div class="matching-board" data-qid="' + escapeHtml(q.id) + '" style="--matchRowH:auto;">';

    // pool раскладываем по НЕзаполненным строкам справа
    var poolSlot = 0;

    rightMapping.forEach(function(rightIdx) {
      var matchedLeft = rightToLeft.hasOwnProperty(rightIdx) ? rightToLeft[rightIdx] : null;
      var isJoined = (matchedLeft !== null);

      html3 += '<div class="matching-line' + (isJoined ? ' is-joined' : '') + '" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';

      // LEFT
      if (isJoined) {
        html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">';
        html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + matchedLeft + '" data-from="match" data-right="' + rightIdx + '">'
              + escapeHtml(q.data.left[matchedLeft])
              + '</div>';
        html3 += '</div>';
      } else {
        var poolLeft = (poolSlot < pool.length) ? pool[poolSlot] : null;

        if (poolLeft !== null && poolLeft !== undefined) {
          html3 += '<div class="match-tile match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">';
          html3 +=   '<div class="match-chip" draggable="true" data-qid="' + escapeHtml(q.id) + '" data-left="' + poolLeft + '" data-from="pool" data-pool-index="' + poolSlot + '">'
                + escapeHtml(q.data.left[poolLeft])
                + '</div>';
          html3 += '</div>';
        } else {
          html3 += '<div class="match-empty match-left-slot match-drop-left" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '" data-pool-slot="' + poolSlot + '">'
                + '<span class="slot-placeholder">Перетащите вариант</span>'
                + '</div>';
        }

        poolSlot++;
      }

      html3 += '<div class="matching-gap"></div>';

      // RIGHT (drop target)
      html3 += '<div class="match-tile match-right-tile match-drop-right" data-qid="' + escapeHtml(q.id) + '" data-right="' + rightIdx + '">'
            + escapeHtml(q.data.right[rightIdx])
            + '</div>';

      html3 += '</div>';
    });

    html3 += '</div>';
    return html3;
  }

  // RANKING (Drag & Drop reorder)
  if (q.type === 'ranking') {
    var items = (q.data && Array.isArray(q.data.items)) ? q.data.items : [];

    // ответ храним как массив индексов исходных items: [2,0,1,...]
    var userOrder = Array.isArray(answer) ? answer.slice() : null;

    // если ответа ещё нет — ставим стартовый порядок 0..n-1
    if (!userOrder || userOrder.length !== items.length) {
      userOrder = items.map(function(_, i){ return i; });
      state.answers[q.id] = userOrder;
    }

    var html = '<div class="ranking-board" data-qid="' + escapeHtml(q.id) + '">';

    userOrder.forEach(function(itemIdx, pos){
      var text = (items[itemIdx] != null) ? String(items[itemIdx]) : ('#' + itemIdx);

      html += ''
        + '<div class="rank-item rank-draggable"'
        + ' draggable="true"'
        + ' data-qid="' + escapeHtml(q.id) + '"'
        + ' data-pos="' + pos + '"'
        + ' data-item="' + itemIdx + '">'
        +   '<span class="rank-grip">' + burgerSvgInline() + '</span>'
        +   '<span class="rank-text">' + escapeHtml(text) + '</span>'
        + '</div>';
    });

    html += '</div>';
    return html;
  }

  // маленький helper для “бургер-иконки”
  function burgerSvgInline(){
    return ''
      + '<svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">'
      + '<path d="M2.5 4.99524H17.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
      + '<path d="M14.1667 9.9952H2.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
      + '<path d="M2.5 14.9951H10.8333" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path>'
      + '</svg>';
  }


  // IMPORTANT: закрываем функцию правильно
  return '<div>Неизвестный тип вопроса</div>';
}

function initRankingDnD(){
  var dragPayload = null; // { qid, fromPos, itemIdx }

  function clearOver(){
    document.querySelectorAll('.rank-item.is-over').forEach(function(n){
      n.classList.remove('is-over');
    });
  }

  function getPayload(e){
    try {
      var raw = e.dataTransfer.getData('application/json');
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  function moveInArray(arr, from, to){
    if (from === to) return arr;
    var copy = arr.slice();
    var item = copy.splice(from, 1)[0];
    copy.splice(to, 0, item);
    return copy;
  }

  document.addEventListener('dragstart', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (!el) return;

    // если показан фидбек/правильные ответы — блокируем перетаскивание
    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    var qid = el.getAttribute('data-qid');
    var fromPos = parseInt(el.getAttribute('data-pos'), 10);
    var itemIdx = parseInt(el.getAttribute('data-item'), 10);
    if (!qid || Number.isNaN(fromPos) || Number.isNaN(itemIdx)) return;

    dragPayload = { qid: qid, fromPos: fromPos, itemIdx: itemIdx };
    el.classList.add('dragging');

    try{
      e.dataTransfer.setData('application/json', JSON.stringify(dragPayload));
      e.dataTransfer.effectAllowed = 'move';
    }catch{}
  });

  document.addEventListener('dragend', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (el) el.classList.remove('dragging');
    dragPayload = null;
    clearOver();
  });

  document.addEventListener('dragover', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    // только внутри того же ranking-board
    var qid = over.getAttribute('data-qid');
    if (!qid) return;

    e.preventDefault();
    clearOver();
    over.classList.add('is-over');

    try{ e.dataTransfer.dropEffect = 'move'; }catch{}
  });

  document.addEventListener('drop', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    e.preventDefault();
    over.classList.remove('is-over');

    var p = getPayload(e) || dragPayload;
    if (!p) return;

    var qid = over.getAttribute('data-qid');
    if (!qid || qid !== p.qid) return;

    var toPos = parseInt(over.getAttribute('data-pos'), 10);
    if (Number.isNaN(toPos)) return;

    var current = state.answers[qid];
    if (!Array.isArray(current)) return;

    // из-за рендера pos актуальный, можно двигать напрямую
    var next = moveInArray(current, p.fromPos, toPos);
    state.answers[qid] = next;

    render();
  });
}

function buildRankingBlockHtml(q, qId, order, locked, correctOrder) {
  var html = '';

  order.forEach(function(itemIdx, pos) {
    var isCorrectPos = locked && itemIdx === correctOrder[pos];
    var rowClass = locked ? (isCorrectPos ? 'correct-answer' : 'incorrect-answer') : '';

    html += '<div class="ranking-item ' + rowClass + '" data-pos="' + pos + '" data-item="' + itemIdx + '">';
    html +=   '<div class="ranking-controls">';
    html +=     '<button type="button" class="rank-btn" data-qid="' + escapeHtml(qId) + '" data-pos="' + pos + '" data-dir="-1"' + (pos === 0 || locked ? ' disabled' : '') + '>▲</button>';
    html +=     '<button type="button" class="rank-btn" data-qid="' + escapeHtml(qId) + '" data-pos="' + pos + '" data-dir="1"' + (pos === order.length - 1 || locked ? ' disabled' : '') + '>▼</button>';
    html +=   '</div>';
    html +=   '<span>' + (pos + 1) + '.</span>';
    html +=   '<span>' + escapeHtml(q.data.items[itemIdx]) + '</span>';
    html +=   '<span class="rank-hint-slot" style="margin-left:8px;font-size:12px;color:#16a34a;"></span>';
    html += '</div>';
  });

  return html;
}

function selectSingle(qId, idx) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;
  state.answers[qId] = idx;
  
  // Убрать selected у всех опций этого вопроса
  var allOptions = document.querySelectorAll('input[name="q_' + qId + '"]');
  allOptions.forEach(function(radio) {
    radio.checked = false;
    radio.parentElement.classList.remove('selected');
  });
  
  // Добавить selected к выбранному
  var selectedOption = document.querySelector('.option[data-index="' + idx + '"]');
  if (selectedOption) {
    selectedOption.classList.add('selected');
    var radio = selectedOption.querySelector('input[type="radio"]');
    if (radio) radio.checked = true;
  }
}

function toggleMultiple(qId, idx) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var current = Array.isArray(state.answers[qId]) ? state.answers[qId].slice() : [];
  var pos = current.indexOf(idx);

  if (pos === -1) current.push(idx);
  else current.splice(pos, 1);

  state.answers[qId] = current;

  // точечное обновление DOM через data-index
  var opt = document.querySelector('.option[data-index="' + idx + '"]');
  if (opt) {
    var cb = opt.querySelector('input[type="checkbox"]');
    var checked = current.indexOf(idx) !== -1;
    if (cb) cb.checked = checked;
    opt.classList.toggle('selected', checked);
  }
}

function setMatchWithMapping(qId, originalLeftIdx, displayRightVal) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var mappingObj = state.shuffleMappings[qId];
  var rightMapping = (mappingObj && mappingObj.right) ? mappingObj.right : null;

  var pairs = state.answers[qId] || {};

  if (displayRightVal === '' || displayRightVal === null || displayRightVal === undefined) {
    delete pairs[originalLeftIdx];
  } else {
    var displayRightIdx = parseInt(displayRightVal, 10);
    if (!Number.isNaN(displayRightIdx) && rightMapping && rightMapping[displayRightIdx] !== undefined) {
      pairs[originalLeftIdx] = rightMapping[displayRightIdx];
    }
  }

  state.answers[qId] = pairs;
}

function setMatch(qId, leftIdx, rightVal) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var pairs = state.answers[qId] || {};

  if (rightVal === '' || rightVal === null || rightVal === undefined) {
    delete pairs[leftIdx];
  } else {
    var n = parseInt(rightVal, 10);
    if (Number.isNaN(n)) delete pairs[leftIdx];
    else pairs[leftIdx] = n;
  }

  state.answers[qId] = pairs;
}

function moveRank(qId, pos, dir) {
  if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

  var fq = state.flatQuestions.find(function(fq) { return fq.question.id === qId; });
  if (!fq) return;

  var q = fq.question;

  var order = Array.isArray(state.answers[qId])
    ? state.answers[qId].slice()
    : q.data.items.map(function(_, i) { return i; });

  var newPos = pos + dir;
  if (newPos < 0 || newPos >= order.length) return;

  var temp = order[pos];
  order[pos] = order[newPos];
  order[newPos] = temp;

  state.answers[qId] = order;

  // точечный перерендер только ranking-блока
  var container = document.getElementById('ranking_' + qId);
  if (container) {
    var locked = false;
    var correctOrder = Array.isArray((q.correct || {}).correctOrder) ? q.correct.correctOrder : order;
    container.innerHTML = buildRankingBlockHtml(q, qId, order, locked, correctOrder);
  }
}


function next() {
  if (!requireAnswerOrToast()) return;

  if (state.currentIndex < state.flatQuestions.length - 1) {
    state.currentIndex++;
    state.feedbackShown = false;
    render();
  }
}


function submit(force) {
  if (state.submitted) return;

  // если не форс — требуем ответ на текущий вопрос
  if (!force) {
    if (!requireAnswerOrToast()) return;
  }

  state.submitted = true;

  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    state.timerInterval = null;
  }

  state.currentIndex = state.flatQuestions.length;
  render();
}



function renderResults() {
  var results = calculateResults();
  var app = document.getElementById('app');

  var pct = Math.round(results.percent);
  var passed = !!results.passed;

  // ring
  var size = 140;
  var stroke = 14;
  var r = (size - stroke) / 2;
  var c = 2 * Math.PI * r;
  var offset = c - (pct / 100) * c;

  var html = '';
  html += '<div class="results-page">';

  // Top hero
  html +=   '<div class="results-hero">';
  html +=     '<div class="results-hero-icon ' + (passed ? 'is-pass' : 'is-fail') + '">';
  html +=       '<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
  html +=         passed
    ? '<path d="M8 21h8"/><path d="M12 17v4"/><path d="M7 4h10"/><path d="M17 4v5a5 5 0 0 1-10 0V4"/><path d="M5 6h2"/><path d="M17 6h2"/>'
    : '<circle cx="12" cy="12" r="9"/><path d="M9 9l6 6"/><path d="M15 9l-6 6"/>';
  html +=       '</svg>';
  html +=     '</div>';
  html +=     '<div class="results-hero-title">' + (passed ? 'Поздравляем!' : 'Тест не пройден') + '</div>';
  html +=     '<div class="results-hero-sub">' + (passed ? 'Вы успешно прошли тест.' : 'Попробуйте ещё раз.') + '</div>';
  html +=   '</div>';

  // Main card
  html +=   '<div class="card results-main-card">';
  html +=     '<div class="results-main-title">' + escapeHtml(TEST_DATA.title || '') + '</div>';
  html +=     '<div class="results-main-sub">Результаты теста</div>';

  html +=     '<div class="results-ring">';
  html +=       '<svg viewBox="0 0 ' + size + ' ' + size + '">';
  html +=         '<circle cx="' + (size/2) + '" cy="' + (size/2) + '" r="' + r + '" class="ring-bg" stroke-width="' + stroke + '" fill="none"></circle>';
  html +=         '<circle cx="' + (size/2) + '" cy="' + (size/2) + '" r="' + r + '" class="ring-fg ' + (passed ? 'is-pass' : 'is-fail') + '" stroke-width="' + stroke + '" fill="none" stroke-linecap="round"';
  html +=           ' style="stroke-dasharray:' + c.toFixed(2) + ';stroke-dashoffset:' + offset.toFixed(2) + '"></circle>';
  html +=       '</svg>';
  html +=       '<div class="results-ring-center">';
  html +=         '<div class="results-ring-pct">' + pct + '%</div>';
  html +=         '<div class="results-ring-label">Баллы</div>';
  html +=       '</div>';
  html +=     '</div>';

  html +=     '<div class="results-stats">';
  html +=       '<div class="results-stat"><div class="v">' + results.totalQuestions + '</div><div class="l">Вопросов</div></div>';
  html +=       '<div class="results-stat"><div class="v">' + results.correct + '/' + results.totalQuestions + '</div><div class="l">Верно</div></div>';
  html +=       '<div class="results-stat"><div class="v">' + results.earnedPoints.toFixed(1) + '</div><div class="l">Баллов</div></div>';
  html +=       '<div class="results-pill ' + (passed ? 'is-pass' : 'is-fail') + '">' + (passed ? 'Пройден' : 'Не пройден') + '</div>';
  html +=     '</div>';
  html +=   '</div>';

  // Topics
  html +=   '<div class="results-section-title">Результаты по темам</div>';
  html +=   '<div class="results-topics-grid">';

  results.topicResults.forEach(function(tr) {
    var tpct = Math.round(tr.percent || 0);
    var tpass = (tr.passed === null) ? null : !!tr.passed;

    html += '<div class="card topic-card">';
    html +=   '<div class="topic-head">';
    html +=     '<div class="topic-left">';
    html +=       '<div class="topic-icon ' + (tpass ? 'is-pass' : 'is-fail') + '">';
    html +=         '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
    html +=           tpass ? '<path d="M20 6 9 17l-5-5"/>' : '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>';
    html +=         '</svg>';
    html +=       '</div>';
    html +=       '<div class="topic-name">' + escapeHtml(tr.topicName || '') + '</div>';
    html +=     '</div>';
    if (tpass !== null) {
      html +=   '<div class="results-pill ' + (tpass ? 'is-pass' : 'is-fail') + '">' + (tpass ? 'Пройден' : 'Нет') + '</div>';
    }
    html +=   '</div>';

    html +=   '<div class="topic-row">';
    html +=     '<div class="k">Вопросов</div>';
    html +=     '<div class="val">' + tr.total + ' / ' + tr.total + ' (' + tpct + '%)</div>';
    html +=   '</div>';

    html +=   '<div class="topic-row">';
    html +=     '<div class="k">Баллов</div>';
    html +=     '<div class="val">' + tr.earnedPoints.toFixed(1) + ' / ' + tr.possiblePoints.toFixed(1) + '</div>';
    html +=   '</div>';

    html +=   '<div class="topic-bar ' + (tpass ? 'is-pass' : 'is-fail') + '"><div style="width:' + Math.min(100, Math.max(0, tpct)) + '%"></div></div>';

    // если у темы есть passRule percent — покажем "Требуется: X%"
    var section = TEST_DATA.sections.find(function(s) { return s.topicId === tr.topicId; });
    if (section && section.topicPassRule && section.topicPassRule.type === 'percent') {
      html += '<div class="topic-required">Требуется: ' + section.topicPassRule.value + '%</div>';
    }

    html += '</div>';
  });

  html +=   '</div>';

  // ========== ДОБАВЬ ЭТОТ КОД ==========
  // Recommended Courses Section (только для непройденных тем)
  var failedTopics = results.topicResults.filter(function(tr) {
    return tr.passed === false && tr.recommendedCourses && tr.recommendedCourses.length > 0;
  });

  if (failedTopics.length > 0) {
    html += '<div class="results-section-title">Рекомендуемые курсы</div>';
    html += '<div style="margin-bottom:14px;color:hsl(var(--muted-foreground));font-size:14px;">';
    html += 'Изучите эти материалы для улучшения знаний по темам, которые требуют внимания.';
    html += '</div>';
    
    failedTopics.forEach(function(tr) {
      html += '<div class="card" style="padding:18px;margin-bottom:12px;">';
      html += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">';
      html += '<div class="topic-icon is-fail">';
      html += '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
      html += '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>';
      html += '</svg>';
      html += '</div>';
      html += '<div class="topic-name">' + escapeHtml(tr.topicName) + '</div>';
      html += '</div>';
      
      tr.recommendedCourses.forEach(function(course) {
        html += '<div style="display:flex;align-items:center;gap:10px;padding:10px;background:hsl(var(--muted)/.5);border-radius:8px;margin-top:8px;">';
        html += '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="hsl(var(--primary))" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">';
        html += '<path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>';
        html += '</svg>';
        html += '<a href="' + escapeHtml(course.url) + '" target="_blank" rel="noopener noreferrer" style="flex:1;color:hsl(var(--primary));text-decoration:none;font-weight:500;font-size:14px;">';
        html += escapeHtml(course.title);
        html += '</a>';
        html += '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="hsl(var(--muted-foreground))" stroke-width="2">';
        html += '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" x2="21" y1="14" y2="3"/>';
        html += '</svg>';
        html += '</div>';
      });
      
      html += '</div>';
    });
  }

  // Actions
  var canFinish = results.passed || results.percent >= 100;
  var noAttempts = TEST_DATA.maxAttempts && !hasAttemptsLeft();
  var timeAndNoAttempts = state.timeExpired && noAttempts;

  html += '<div class="results-actions">';

  if (canFinish || noAttempts || timeAndNoAttempts) {
    html += '<button class="btn" onclick="finishAndClose()">Завершить тест</button>';
  } else {
    html += '<button class="btn btn-outline" onclick="restart()">Пройти заново</button>';
  }

  html += '</div>';

  app.innerHTML = html;
  //finishScorm(results);
}


function restart() {
  if (!hasAttemptsLeft()) {
    showToast('Попытки закончились', 'warn');
    return;
  }
  state.phase = 'start';
  state.currentIndex = 0;
  state.answers = {};
  state.variant = null;
  state.flatQuestions = [];
  state.submitted = false;
  state.feedbackShown = false;
  state.timeExpired = false;

  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    state.timerInterval = null;
  }
  state.remainingSeconds = null;

  generateVariant();
  render();
}

var scormFinished = false;

function finishAndClose() {
  if (scormFinished) return;
  scormFinished = true;

  var results = calculateResults();

  var attemptsExhausted = !!TEST_DATA.maxAttempts && !hasAttemptsLeft();
  var realPassed = !!results.passed;

  // по умолчанию — честно
  var passedForLms = realPassed;

  // если время вышло — считаем провалом (и не закрываем "читом")
  if (state.timeExpired) {
    passedForLms = false;
  }

  // ✅ ХАК ДЛЯ WebSoft:
  // если попытки кончились и тест НЕ пройден — закрываем курс, иначе он висит "в процессе"
  if (attemptsExhausted && !realPassed && !state.timeExpired) {
    passedForLms = true;

    // маркер в данные, чтобы было видно, что фактически не сдал
    try {
      SCORM.setValue('cmi.comments_from_learner', 'ATTEMPTS_EXHAUSTED: FAILED (forced close)');
    } catch (e) {}
  }

  finishScorm(results, passedForLms);

  try { SCORM.commit(); } catch (e) {}
  try { SCORM.terminate(); } catch (e) {}
  try { window.close(); } catch (e) {}
}


window.finishAndClose = finishAndClose;


function calculateResults() {
  var totalEarnedPoints = 0;  // Sum of earned points (weighted by question points)
  var totalPossiblePoints = 0; // Total possible points
  var totalFullyCorrect = 0; // Fully correct count
  var totalQuestions = 0;
  var topicData = {};

  state.flatQuestions.forEach(function(fq) {
    var q = fq.question;
    var answer = state.answers[q.id];
    var scoreRatio = checkAnswer(q, answer);
    var qPoints = q.points || 1;

    totalPossiblePoints += qPoints;
    totalEarnedPoints += qPoints * scoreRatio;
    totalQuestions++;
    if (scoreRatio === 1) totalFullyCorrect++;

    if (!topicData[fq.topicId]) {
      var section = TEST_DATA.sections.find(function(s) { return s.topicId === fq.topicId; });
      topicData[fq.topicId] = {
        topicId: fq.topicId,
        topicName: fq.topicName,
        correct: 0,
        earnedPoints: 0,
        possiblePoints: 0,
        total: 0,
        passRule: section.topicPassRule,
        topicFeedback: section.topicFeedback || null,
        recommendedCourses: section.recommendedCourses || []
      };
    }
    topicData[fq.topicId].total++;
    topicData[fq.topicId].possiblePoints += qPoints;
    topicData[fq.topicId].earnedPoints += qPoints * scoreRatio;
    if (scoreRatio === 1) topicData[fq.topicId].correct++;
  });

  // Use point-based percentage for overall score (matches backend)
  var overallPercent = totalPossiblePoints > 0 ? (totalEarnedPoints / totalPossiblePoints) * 100 : 0;
  // Pass rule evaluation: percent type uses point-based percentage, count type uses fully correct count
  var overallPassed = checkPassRuleWithPartial(TEST_DATA.overallPassRule, overallPercent, totalFullyCorrect);

  var topicResults = [];
  var allTopicsPassed = true;

  Object.keys(topicData).forEach(function(tid) {
    var td = topicData[tid];
    // Use point-based percentage (matches backend)
    td.percent = td.possiblePoints > 0 ? (td.earnedPoints / td.possiblePoints) * 100 : 0;
    if (td.passRule) {
      td.passed = checkPassRuleWithPartial(td.passRule, td.percent, td.correct);
      if (!td.passed) allTopicsPassed = false;
    } else {
      td.passed = null;
    }
    topicResults.push(td);
  });

  var passed = overallPassed && allTopicsPassed;

  return {
    correct: totalFullyCorrect,
    totalQuestions: totalQuestions,
    earnedPoints: totalEarnedPoints,
    possiblePoints: totalPossiblePoints,
    percent: overallPercent,
    passed: passed,
    topicResults: topicResults
  };
}

// Returns a score between 0 and 1 (supports partial credit)
function checkAnswer(q, answer) {
  if (answer === undefined || answer === null) return 0;

  var correct = q.correct || {};

  // SINGLE
  if (q.type === 'single') {
    return answer === correct.correctIndex ? 1 : 0;
  }

  // MULTIPLE — строгое совпадение множеств
  if (q.type === 'multiple') {
    var correctIndices = Array.isArray(correct.correctIndices) ? correct.correctIndices.slice() : [];
    var user = Array.isArray(answer) ? answer.slice() : [];

    if (correctIndices.length === 0) return 0;
    if (user.length !== correctIndices.length) return 0;

    correctIndices.sort();
    user.sort();

    for (var i = 0; i < correctIndices.length; i++) {
      if (correctIndices[i] !== user[i]) return 0;
    }
    return 1;
  }

  // MATCHING — все пары должны совпасть
  if (q.type === 'matching') {
    var pairs = (answer && typeof answer === 'object') ? answer : {};
    var correctPairs = Array.isArray(correct.pairs) ? correct.pairs : [];

    if (Object.keys(pairs).length !== correctPairs.length) return 0;

    for (var i = 0; i < correctPairs.length; i++) {
      var p = correctPairs[i];
      if (pairs[p.left] !== p.right) return 0;
    }
    return 1;
  }

  // RANKING — порядок должен совпасть полностью
  if (q.type === 'ranking') {
    var order = Array.isArray(answer) ? answer : [];
    var correctOrder = Array.isArray(correct.correctOrder) ? correct.correctOrder : [];

    if (order.length !== correctOrder.length) return 0;

    for (var i = 0; i < order.length; i++) {
      if (order[i] !== correctOrder[i]) return 0;
    }
    return 1;
  }

  return 0;
}

function checkPassRule(rule, correct, total) {
  if (!rule) return true;
  if (rule.type === 'percent') {
    return (correct / total) * 100 >= rule.value;
  }
  return correct >= rule.value;
}

// Pass rule check that properly handles partial credit
// For percent rules, uses the already-calculated percent (from earned/possible)
// For count rules, uses the fully correct count
function checkPassRuleWithPartial(rule, percent, fullyCorrectCount) {
  if (!rule) return true;
  if (rule.type === 'percent') {
    return percent >= rule.value;
  }
  return fullyCorrectCount >= rule.value;
}

function finishScorm(results, passedForLms) {
  var objectives = results.topicResults.map(function(tr) {
    return {
      id: 'topic_' + tr.topicId,
      score: Math.round(tr.percent),
      status: tr.passed === null ? 'unknown' : (tr.passed ? 'passed' : 'failed')
    };
  });

  var interactions = [];

  function to1(x) { return typeof x === 'number' ? x + 1 : x; }

  function mapScormType(q) {
    if (q.type === 'single') return 'choice';
    if (q.type === 'multiple') return 'choice';
    if (q.type === 'matching') return 'matching';
    if (q.type === 'ranking') return 'sequencing';
    return 'other';
  }

  function formatResponse(q, ans) {
    if (ans == null) return '';

    if (q.type === 'single') return String(to1(ans));
    if (q.type === 'multiple') return ans.map(to1).join(',');
    if (q.type === 'ranking') return ans.map(to1).join(',');
    if (q.type === 'matching') {
      return Object.keys(ans)
        .sort((a,b)=>a-b)
        .map(k => to1(+k) + '-' + to1(ans[k]))
        .join(',');
    }
    return '';
  }

  function getCorrectAnswerFor(q) {
    var c = q.correct || {};
    if (q.type === 'single') return c.correctIndex;
    if (q.type === 'multiple') return c.correctIndices || [];
    if (q.type === 'ranking') return c.correctOrder || [];
    if (q.type === 'matching') {
      var m = {};
      (c.pairs || []).forEach(p => m[p.left] = p.right);
      return m;
    }
    return null;
  }

  state.flatQuestions.forEach(function(fq) {
    var q = fq.question;
    var ans = state.answers[q.id];
    var fullCorrect = checkAnswer(q, ans) === 1;

    interactions.push({
      id: 'q_' + q.id,
      type: mapScormType(q),
      result: fullCorrect ? 'correct' : 'incorrect',
      response: formatResponse(q, ans),
      correct: formatResponse(q, getCorrectAnswerFor(q)),
      description: q.prompt || ''
    });
  });

  var percentScore = Math.round(results.percent);
  SCORM.finish(percentScore, 100, passedForLms, objectives, interactions);
}

function escapeHtml(str) {
  if (!str) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}
    function readSuspendObj() {
  try {
    var raw = SCORM.getValue('cmi.suspend_data') || '';
    if (!raw) return {};
    return JSON.parse(raw);
  } catch (e) {
    return {};
  }
}

function writeSuspendObj(obj) {
  try {
    var raw = JSON.stringify(obj || {});
    // SCORM 2004 suspend_data обычно до ~64KB, нам хватит
    SCORM.setValue('cmi.suspend_data', raw);
    SCORM.commit();
  } catch (e) {}
}

function getAttemptsUsed() {
  var s = readSuspendObj();
  return typeof s.attemptsUsed === 'number' ? s.attemptsUsed : 0;
}

function setAttemptsUsed(n) {
  var s = readSuspendObj();
  s.attemptsUsed = n;
  s.lastUpdated = new Date().toISOString();
  writeSuspendObj(s);
}

function hasAttemptsLeft() {
  if (!TEST_DATA.maxAttempts) return true; // если лимит не задан — не ограничиваем
  return getAttemptsUsed() < TEST_DATA.maxAttempts;
}

// Увеличиваем попытку 1 раз на запуск теста
function registerAttemptStart() {
  if (!TEST_DATA.maxAttempts) return true;

  var used = getAttemptsUsed();
  if (used >= TEST_DATA.maxAttempts) return false;

  setAttemptsUsed(used + 1);
  return true;
}

;


Проверь
ChatGPT сказал:

Думал на протяжении 1m 19s
Проверил: сейчас ranking DnD в таком виде не заработает и ещё подсветка правильности для ranking сломается, потому что есть 4 ключевые проблемы.

Что не так (и почему)
initRankingDnD() нигде не вызывается
В window.onload у тебя есть bindRankingClicksOnce() и bindMatchingDnDOnce(), но нет вызова для ranking DnD.

Внутри initRankingDnD() используется closestByClass(...), но он НЕ в глобальной области видимости
closestByClass объявлен внутри bindMatchingDnDOnce(), поэтому initRankingDnD() его не видит → будет ReferenceError.

highlightRanking() ищет старую верстку:

document.querySelectorAll('#ranking_' + q.id + ' .ranking-item')
Но ты теперь рендеришь:

.ranking-board

.rank-item

→ подсветка correct/incorrect для ranking после confirmAnswer() не применится.

lockAnswerOptions() не блокирует DnD (он блокирует только кнопки ▲▼, которых в DnD-версии уже нет)

Минимальные правки (вставь ровно это)
1) В window.onload добавь вызов
После bindMatchingDnDOnce(); добавь:

bindRankingDnDOnce();
2) Замени initRankingDnD() на версию “once” (или просто добавь guard)
Вставь новую функцию (можешь заменить твою initRankingDnD целиком):

var __rankDndBound = false;

function bindRankingDnDOnce(){
  if (__rankDndBound) return;
  __rankDndBound = true;

  var dragPayload = null; // { qid, fromPos, itemIdx }

  function closestByClass(node, cls) {
    var el = node;
    while (el && el !== document) {
      if (el.classList && el.classList.contains(cls)) return el;
      el = el.parentNode;
    }
    return null;
  }

  function clearOver(){
    document.querySelectorAll('.rank-item.is-over').forEach(function(n){
      n.classList.remove('is-over');
    });
  }

  function getPayload(e){
    try {
      var raw = e.dataTransfer.getData('application/json');
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (err) { return null; }
  }

  function moveInArray(arr, from, to){
    if (from === to) return arr;
    var copy = arr.slice();
    var item = copy.splice(from, 1)[0];
    copy.splice(to, 0, item);
    return copy;
  }

  document.addEventListener('dragstart', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (!el) return;

    // блокируем DnD после принятия
    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) {
      e.preventDefault();
      return;
    }

    var qid = el.getAttribute('data-qid');
    var fromPos = parseInt(el.getAttribute('data-pos'), 10);
    var itemIdx = parseInt(el.getAttribute('data-item'), 10);
    if (!qid || Number.isNaN(fromPos) || Number.isNaN(itemIdx)) return;

    dragPayload = { qid: qid, fromPos: fromPos, itemIdx: itemIdx };
    el.classList.add('dragging');

    try{
      e.dataTransfer.setData('application/json', JSON.stringify(dragPayload));
      e.dataTransfer.effectAllowed = 'move';
    }catch(err){}
  });

  document.addEventListener('dragend', function(e){
    var el = closestByClass(e.target, 'rank-draggable');
    if (el) el.classList.remove('dragging');
    dragPayload = null;
    clearOver();
  });

  document.addEventListener('dragover', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    clearOver();
    over.classList.add('is-over');

    try{ e.dataTransfer.dropEffect = 'move'; }catch(err){}
  });

  document.addEventListener('drop', function(e){
    var over = closestByClass(e.target, 'rank-item');
    if (!over) return;

    if (TEST_DATA.showCorrectAnswers && state.feedbackShown) return;

    e.preventDefault();
    over.classList.remove('is-over');

    var p = getPayload(e) || dragPayload;
    if (!p) return;

    var qid = over.getAttribute('data-qid');
    if (!qid || qid !== p.qid) return;

    var toPos = parseInt(over.getAttribute('data-pos'), 10);
    if (Number.isNaN(toPos)) return;

    var current = state.answers[qid];
    if (!Array.isArray(current)) return;

    state.answers[qid] = moveInArray(current, p.fromPos, toPos);
    render();
  });
}
3) Почини highlightRanking() под новую верстку
Замени твою функцию highlightRanking на эту:

function highlightRanking(q, answer) {
  var correctOrder = Array.isArray((q.correct || {}).correctOrder) ? q.correct.correctOrder : [];
  if (!correctOrder.length) return;

  var rows = document.querySelectorAll('.ranking-board[data-qid="' + q.id + '"] .rank-item');
  if (!rows || !rows.length) return;

  rows.forEach(function(row, pos) {
    row.classList.remove('correct-answer', 'incorrect-answer');

    var itemIdx = parseInt(row.getAttribute('data-item'), 10);
    if (Number.isNaN(itemIdx)) return;

    var ok = (itemIdx === correctOrder[pos]);

    if (ok) {
      row.classList.add('correct-answer');
    } else {
      row.classList.add('incorrect-answer');
    }
  });
}
Если хочешь как раньше показывать “(должен быть: X)” — добавим в разметку .rank-hint-slot и допишем 3 строки.

4) В lockAnswerOptions() добавь блокировку DnD
В конец функции добавь:

  // ranking DnD
  var rankItems = document.querySelectorAll('.rank-draggable');
  rankItems.forEach(function(el) {
    el.setAttribute('draggable', 'false');
    el.style.cursor = 'default';
  });
Важно: у тебя остался “старый ranking” (кнопки ▲▼)
Сейчас у тебя одновременно есть:

bindRankingClicksOnce() + moveRank() + buildRankingBlockHtml() (старый режим)

новый DnD-рендер

Они не мешают, но старый код станет неиспользуемым, если ты окончательно переходишь на DnD. Могу подсказать, что можно безопасно удалить, чтобы не раздувать сборку.

Если скажешь, хочешь ли ты оставить ▲▼ как запасной способ (для клавиатуры) — я покажу как встроить эти кнопки прямо внутрь .rank-item без конфликта с DnD.





Файл не выбранФайл не выбран
ChatGPT может допускать ошибки. Проверяйте важную информацию. Смотрите настройки cookie-файлов.
